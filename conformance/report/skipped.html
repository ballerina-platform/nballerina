<html>
<head>
<title> Skipped </title>
</head>
<body>
<h1>Skipped</h1>
<h3>less_than_or_equal_expression.balt</h3>
<pre>Test-Case: output<br>Description: Test less than or equal expression when one operand is positive and other one is negative.<br>Labels: DecimalFloatingPointNumber, DecimalNumber, float, multiplicative-expr, relational-expr, unary-minus<br><br>function init() {<br>   float a = -0/0;<br>   float b = 2.0;<br>   float c = -343545.45;<br>   float d = 32345.54;<br>   float e = +0;<br>   float f = -0;<br>   io:println(a <= b); // @output false<br>   io:println(b <= a); // @output false<br>   io:println(c <= d); // @output true<br>   io:println(d <= c); // @output false<br>   io:println(e <= f); // @output true<br>   io:println(f <= e); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test less than or equal expression when one operand is optional positive and other one is optional<br>             negative float.<br>Labels: DecimalFloatingPointNumber, DecimalNumber, float, multiplicative-expr, optional-type, relational-expr,<br>        unary-minus, unary-plus<br><br>function init() {<br>   float? a = -0/0;<br>   float? b = 2.0;<br>   float? c = -343545.45;<br>   float? d = 32345.54;<br>   float? e = +0;<br>   float? f = -0;<br>   io:println(a <= b); // @output false<br>   io:println(b <= a); // @output false<br>   io:println(c <= d); // @output true<br>   io:println(d <= c); // @output false<br>   io:println(e <= f); // @output true<br>   io:println(f <= e); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test binary conditional expressions with less than or equal expression condition.<br>Labels: ternary-conditional-expr, DecimalNumber, int, relational-expr<br><br>function init() {<br>   int a = 12;<br>   int b = 15;<br>   int c = a <= b ? 2 : a;<br>   io:println(c); // @output 2<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test less than or equal expression, var as operands.<br>Labels: DecimalNumber, relational-expr, var<br><br>function init() {<br>   var a = 12;<br>   var b = 15;<br>   io:println(a <= b); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test less than or equal expression in module level.<br>Labels: DecimalNumber, module-init-var-decl, relational-expr, var<br><br>var a = 12;<br>var b = 15;<br>boolean c = a <= b;<br><br>function init() {<br>   io:println(c); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test the result type of less than or equal expression is boolean.<br>Labels: boolean, DecimalNumber, relational-expr, var<br><br>function init() {<br>   var a = 1 <= 2;<br>   boolean b = a;<br>   io:println(b); // @output true<br>}<br></pre>
<h3>greater_than_or_equal_expression.balt</h3>
<pre>Test-Case: output<br>Description: Test greater than or equal expression when one operand is positive and other one is negative.<br>Labels: DecimalFloatingPointNumber, DecimalNumber, float, multiplicative-expr, relational-expr, unary-minus, unary-plus<br><br>function init() {<br>   float a = -0/0;<br>   float b = 2.0;<br>   float c = -343545.45;<br>   float d = 32345.54;<br>   float e = +0;<br>   float f = -0;<br>   io:println(a >= b); // @output false<br>   io:println(b >= a); // @output false<br>   io:println(c >= d); // @output false<br>   io:println(d >= c); // @output true<br>   io:println(e >= f); // @output true<br>   io:println(f >= e); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test greater than or equal expression when one operand is optional positive and other one is optional<br>             negative float.<br>Labels: DecimalFloatingPointNumber, DecimalNumber, float, multiplicative-expr, optional-type, relational-expr,<br>        unary-minus, unary-plus<br><br>function init() {<br>   float? a = -0/0;<br>   float? b = 2.0;<br>   float? c = -343545.45;<br>   float? d = 32345.54;<br>   float? e = +0;<br>   float? f = -0;<br>   io:println(a >= b); // @output false<br>   io:println(b >= a); // @output false<br>   io:println(c >= d); // @output false<br>   io:println(d >= c); // @output true<br>   io:println(e >= f); // @output true<br>   io:println(f >= e); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test binary conditional expressions with greater than or equal expression condition.<br>Labels: ternary-conditional-expr, DecimalNumber, int, relational-expr<br><br>function init() {<br>   int a = 12;<br>   int b = 15;<br>   int c = a >= b ? 2 : a;<br>   io:println(c); // @output 12<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test greater than or equal expression, var as operands.<br>Labels: DecimalNumber, relational-expr, var<br><br>function init() {<br>   var a = 12;<br>   var b = 15;<br>   io:println(a >= b); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test greater than or equal expression in module level.<br>Labels: DecimalNumber, module-init-var-decl, relational-expr, var<br><br>var a = 12;<br>var b = 15;<br>boolean c = a >= b;<br><br>function init() {<br>   io:println(c); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test the result type of greater than or equal expression is boolean.<br>Labels: boolean, DecimalNumber, relational-expr, var<br><br>function init() {<br>   var a = 1 >= 2;<br>   boolean b = a;<br>   io:println(b); // @output false<br>}<br></pre>
<h3>less_than_expression.balt</h3>
<pre>Test-Case: output<br>Description: Test less than expression when one operand is positive and other one is negative.<br>Labels: DecimalFloatingPointNumber, DecimalNumber, float, multiplicative-expr, relational-expr, unary-minus, unary-plus<br><br>function init() {<br>   float a = -0/0;<br>   float b = 2.0;<br>   float c = -343545.45;<br>   float d = 32345.54;<br>   float e = +0;<br>   float f = -0;<br>   io:println(a < b); // @output false<br>   io:println(b < a); // @output false<br>   io:println(c < d); // @output true<br>   io:println(d < c); // @output false<br>   io:println(e < f); // @output false<br>   io:println(f < e); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test less than expression when one operand is optional positive and other one is optional negative float.<br>Labels: DecimalFloatingPointNumber, DecimalNumber, float, optional-type, multiplicative-expr, relational-expr,<br>        unary-minus, unary-plus<br><br>function init() {<br>   float? a = -0/0;<br>   float? b = 2.0;<br>   float? c = -343545.45;<br>   float? d = 32345.54;<br>   float? e = +0;<br>   float? f = -0;<br>   io:println(a < b); // @output false<br>   io:println(b < a); // @output false<br>   io:println(c < d); // @output true<br>   io:println(d < c); // @output false<br>   io:println(e < f); // @output false<br>   io:println(f < e); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test binary conditional expressions with less than expression condition.<br>Labels: ternary-conditional-expr, DecimalNumber, int, relational-expr<br><br>function init() {<br>   int a = 12;<br>   int b = 15;<br>   int c = a < b ? 2 : a;<br>   io:println(c); // @output 2<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test less than expression, var as operands.<br>Labels: DecimalNumber, relational-expr, var<br><br>function init() {<br>   var a = 12;<br>   var b = 15;<br>   io:println(a < b); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test less than expression in module level.<br>Labels: DecimalNumber, module-init-var-decl, relational-expr, var<br><br>var a = 12;<br>var b = 15;<br>boolean c = a < b;<br><br>function init() {<br>   io:println(c); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test the result type of less than expression is boolean.<br>Labels: boolean, DecimalNumber, relational-expr, var<br><br>function init() {<br>   var a = 1 < 2;<br>   boolean b = a;<br>   io:println(b); // @output true<br>}<br></pre>
<h3>greater_than_expression.balt</h3>
<pre>Test-Case: output<br>Description: Test greater than expression when one operand is positive and other one is negative.<br>Labels: DecimalFloatingPointNumber, DecimalNumber, float, multiplicative-expr, relational-expr, unary-minus<br><br>function init() {<br>   float a = -0/0;<br>   float b = 2.0;<br>   float c = -343545.45;<br>   float d = 32345.54;<br>   float e = +0;<br>   float f = -0;<br>   io:println(a > b); // @output false<br>   io:println(b > a); // @output false<br>   io:println(c > d); // @output false<br>   io:println(d > c); // @output true<br>   io:println(e > f); // @output false<br>   io:println(f > e); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test greater than expression when one operand is optional positive and other one is optional negative float.<br>Labels: DecimalFloatingPointNumber, DecimalNumber, float, multiplicative-expr, optional-type, relational-expr,<br>        unary-minus, unary-plus<br><br>function init() {<br>   float? a = -0/0;<br>   float? b = 2.0;<br>   float? c = -343545.45;<br>   float? d = 32345.54;<br>   float? e = +0;<br>   float? f = -0;<br>   io:println(a > b); // @output false<br>   io:println(b > a); // @output false<br>   io:println(c > d); // @output false<br>   io:println(d > c); // @output true<br>   io:println(e > f); // @output false<br>   io:println(f > e); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test binary conditional expressions with greater than expression condition.<br>Labels: ternary-conditional-expr, DecimalNumber, int, relational-expr<br><br>function init() {<br>   int a = 12;<br>   int b = 15;<br>   int c = a > b ? 2 : a;<br>   io:println(c); // @output 12<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test greater than or equal expression, var as operands.<br>Labels: DecimalNumber, relational-expr, var<br><br>function init() {<br>   var a = 12;<br>   var b = 15;<br>   io:println(a > b); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test greater than expression in module level.<br>Labels: DecimalNumber, module-init-var-decl, relational-expr, var<br><br>var a = 12;<br>var b = 15;<br>boolean c = a > b;<br><br>function init() {<br>   io:println(c); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test the result type of greater than expression is boolean.<br>Labels: boolean, DecimalNumber, relational-expr, var<br><br>function init() {<br>   var a = 1 > 2;<br>   boolean b = a;<br>   io:println(b); // @output false<br>}<br></pre>
<h3>binary_bitwise_and_expr.balt</h3>
<pre>Test-Case: output<br>Description: Test bitwise and expression always evaluates to 0 when at least one operand is 0.<br>Labels: binary-bitwise-expr, DecimalNumber, int, signed-zero, unary-minus, unary-plus<br><br>function init() {<br>    int a = 53443;<br>    int b = 0;<br>    int c = +0;<br>    int d = -0;<br><br>    io:println(543434343434 & 0); // @output 0<br>    io:println(0 & 787654322); // @output 0<br>    io:println(0 & 0); // @output 0<br>    io:println(0 & a); // @output 0<br>    io:println(a & 0); // @output 0<br>    io:println(a & b); // @output 0<br>    io:println(b & 6453564654); // @output 0<br>    io:println(b & b); // @output 0<br>    io:println(-4434353 & b); // @output 0<br>    io:println(94434843 & c); // @output 0<br>    io:println(-6534353 & d); // @output 0<br>    io:println(c & c); // @output 0<br>    io:println(d & d); // @output 0<br>    io:println(-0 & -0); // @output 0<br>    io:println(+0 & +0); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test bitwise and expression always evaluates to value v when the value of both operands are v.<br>Labels: binary-bitwise-expr, DecimalNumber, int, unary-minus, unary-plus<br><br>function init() {<br>    int a = 99443;<br>    int b = 99443;<br>    int c = -223;<br><br>    io:println(543434343434 & 543434343434); // @output 543434343434<br>    io:println(0 & 0); // @output 0<br>    io:println(a & a); // @output 99443<br>    io:println(a & b); // @output 99443<br>    io:println(b & a); // @output 99443<br>    io:println(3 & 3); // @output 3<br>    io:println(-3 & -3); // @output -3<br>    io:println(c & c); // @output -223<br>    io:println(+987654321 & +987654321); // @output 987654321<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test if the type of either operand is a subtype of int:UnsignedK when K is 8, 16 or 32, then the static<br>             type of the result is int:UnsignedN where N is the smallest such K via inference.<br>Labels: binary-bitwise-expr, byte, int, int:Unsigned8, int:Unsigned16, int:Unsigned32, var<br><br>function init() {<br>    int a = 9876;<br>    int:Unsigned32 b = 5454;<br>    var c = a & b;<br>    int:Unsigned32 result1 = c;<br>    io:println(result1); // @output 1028<br><br>    int:Unsigned16 d = 4344;<br>    var e = b & d;<br>    int:Unsigned16 result2 = e;<br>    io:println(result2); // @output 4168<br><br>    int:Unsigned8 f = 44;<br>    var g = d & f;<br>    int:Unsigned8 result3 = g;<br>    io:println(result3); // @output 40<br><br>    var h = f & g;<br>    int:Unsigned8 result4 = h;<br>    io:println(result4); // @output 40<br><br>    var i = f & g;<br>    byte result5 = h;<br>    io:println(result5); // @output 40<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test if the type of either operand is a subtype of int:UnsignedK when K is 8, 16 or 32, then the static<br>             type of the result is int:UnsignedN where N is the smallest such K via invalid assignment with inference.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Unsigned8, int:Unsigned16, int:Unsigned32, var<br><br>function errorFunction() {<br>    int a = 4343;<br>    int b = 8;<br>    var result1 = a & b;<br>    int:Unsigned32 _ = result1; // @error the static type of the result is int<br><br>    int d = 9876;<br>    int:Unsigned32 e = 5454;<br>    var result2 = d & e;<br>    int:Unsigned16 _ = result2; // @error the static type of the result is Unsigned32<br><br>    int g = 9876;<br>    int:Unsigned16 h = 5454;<br>    var result3 = g & h;<br>    int:Unsigned8 _ = result3; // @error the static type of the result is Unsigned16<br><br>    byte _ = result3; // @error the static type of the result is Unsigned16<br><br>    int:Signed8 k = 12;<br>    int:Signed16 m = 4434;<br>    var result4 = k & m;<br>    int:Signed8 _ = result4; // @error the static type of the result is int<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test bitwise and expression evaluates to nil when either operand is nil.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, <br>        int:Unsigned16, int:Unsigned32, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>    int? a = 43;<br><br>    byte? b = 5;<br><br>    int:Signed32? c = -21474836;<br>    int:Signed16? d = -454;<br>    int:Signed8? e = 100;<br><br>    int:Unsigned32? f = 21474836;<br>    int:Unsigned16? g = 54522;<br>    int:Unsigned8? h = 255;<br><br>    int? i = ();<br>    byte? j = ();<br>    int:Signed32? k = ();<br>    int:Unsigned16? m = ();<br><br>    printResult(a & i); // @output ()<br>    printResult(a & j); // @output ()<br>    printResult(k & a); // @output ()<br>    printResult(m & a); // @output ()<br><br>    printResult(b & i); // @output ()<br>    printResult(b & j); // @output ()<br>    printResult(b & k); // @output ()<br>    printResult(b & m); // @output ()<br><br>    printResult(c & i); // @output ()<br>    printResult(c & j); // @output ()<br>    printResult(k & c); // @output ()<br>    printResult(c & m); // @output ()<br><br>    printResult(d & i); // @output ()<br>    printResult(d & j); // @output ()<br>    printResult(d & k); // @output ()<br>    printResult(d & m); // @output ()<br><br>    printResult(e & i); // @output ()<br>    printResult(e & j); // @output ()<br>    printResult(e & k); // @output ()<br>    printResult(e & m); // @output ()<br><br>    printResult(f & i); // @output ()<br>    printResult(f & j); // @output ()<br>    printResult(f & k); // @output ()<br>    printResult(f & m); // @output ()<br><br>    printResult(g & i); // @output ()<br>    printResult(g & j); // @output ()<br>    printResult(g & k); // @output ()<br>    printResult(g & m); // @output ()<br><br>    printResult(h & i); // @output ()<br>    printResult(h & j); // @output ()<br>    printResult(h & k); // @output ()<br>    printResult(h & m); // @output ()<br><br>    printResult(i & i); // @output ()<br>    printResult(i & j); // @output ()<br>    printResult(i & k); // @output ()<br>    printResult(i & m); // @output ()<br><br>    printResult(j & j); // @output ()<br>    printResult(j & k); // @output ()<br>    printResult(j & m); // @output ()<br><br>    printResult(k & k); // @output ()<br>    printResult(k & m); // @output ()<br><br>    printResult(m & m); // @output ()<br>}<br><br>function printResult(int? result) {<br>    io:println(result.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test the static type of bitwise and expression will be a nillable type when at least one operand is <br>             nillable via inference.<br>Labels: binary-bitwise-expr, byte, int, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, <br>        numeric-nil-lifting, optional-type, value:toBalString, var<br><br>function init() {<br>    int? a = 9876;<br>    int:Unsigned32 b = 5454;<br>    var c = a & b;<br>    int:Unsigned32? result1 = c;<br>    io:println(result1); // @output 1028<br><br>    int:Unsigned16? d = 4344;<br>    var e = b & d;<br>    int:Unsigned16? result2 = e;<br>    io:println(result2); // @output 4168<br><br>    int:Unsigned8? f = 44;<br>    var g = d & f;<br>    int:Unsigned8? result3 = g;<br>    io:println(result3); // @output 40<br><br>    var h = f & g;<br>    int:Unsigned8? result4 = h;<br>    io:println(result4); // @output 40<br><br>    int i = 45343;<br>    int? j = 5454;<br>    int? result5 = i & j;<br>    io:println(result5); // @output 4366<br><br>    int m = 5454545343;<br>    byte? n = 43;<br>    byte? result6 = m & n;<br>    io:println(result6); // @output 43<br><br>    int q = 5454545343;<br>    byte? r = ();<br>    int:Unsigned8? result7 = q & r;<br>    io:println(result7.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test the static type of bitwise and expression will be a nillable type when at least one operand is nillable<br>             via inference and invalid assignments.<br>Labels: binary-bitwise-expr, byte, int, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, <br>        numeric-nil-lifting, optional-type, var<br><br>function errorFunction() {<br>    int? a = 9876;<br>    int:Unsigned32 b = 5454;<br>    var c = a & b;<br>    int:Unsigned32 _ = c; // @error the static type of the result is int:Unsigned32?<br><br>    int:Unsigned16? d = 4344;<br>    var e = b & d;<br>    int:Unsigned16 _ = e; // @error the static type of the result is int:Unsigned16?<br><br>    int:Unsigned8? f = 44;<br>    var g = d & f;<br>    int:Unsigned8 _ = g; // @error the static type of the result is int:Unsigned8?<br><br>    var h = f & g;<br>    int:Unsigned8 _ = h; // @error the static type of the result is int:Unsigned8?<br><br>    int i = 45343;<br>    int? j = 5454;<br>    int _ = i & j; // @error the static type of the result is int?<br><br>    int m = 5454545343;<br>    byte? n = 43;<br>    byte _ = m & n; // @error the static type of the result is byte?<br><br>    int p = 5454545343;<br>    byte? q = ();<br>    int:Unsigned8 _ = p & q; // @error the static type of the result is byte?<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test bitwise and expression at module level.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, <br>        int:Unsigned16, int:Unsigned32, module-init-var-decl, unary-minus<br><br>int a = 43;<br><br>byte b = 5;<br><br>int:Signed32 c = -21474836;<br>int:Signed16 d = -454;<br>int:Signed8 e = 100;<br><br>int:Unsigned32 f = 21474836;<br>int:Unsigned16 g = 54522;<br>int:Unsigned8 h = 255;<br><br>int result1 = a & b;<br>int result2 = a & c;<br>int result3 = a & d;<br>int result4 = a & e;<br>int result5 = a & f;<br>int result6 = a & g;<br>int result7 = a & h;<br><br>int result8 = b & b;<br>int result9 = b & c;<br>int result10 = b & d;<br>int result11 = b & e;<br>int result12 = b & f;<br>int result13 = b & g;<br>int result14 = b & h;<br><br>int result15 = c & c;<br>int result16 = c & d;<br>int result17 = c & e;<br>int result18 = c & f;<br>int result19 = c & g;<br>int result20 = c & h;<br><br>int result21 = d & d;<br>int result22 = d & e;<br>int result23 = d & f;<br>int result24 = d & g;<br>int result25 = d & h;<br><br>int result26 = e & e;<br>int result27 = e & f;<br>int result28 = e & g;<br>int result29 = e & h;<br><br>int result30 = f & f;<br>int result31 = f & g;<br>int result32 = f & h;<br><br>int result33 = g & g;<br>int result34 = g & h;<br><br>int result35 = h & h;<br><br>function init() {<br>    printResult(result1); // @output 1<br>    printResult(result2); // @output 40<br>    printResult(result3); // @output 42<br>    printResult(result4); // @output 32<br>    printResult(result5); // @output 0<br>    printResult(result6); // @output 42<br>    printResult(result7); // @output 43<br><br>    printResult(result8); // @output 5<br>    printResult(result9); // @output 4<br>    printResult(result10); // @output 0<br>    printResult(result11); // @output 4<br>    printResult(result12); // @output 4<br>    printResult(result13); // @output 0<br>    printResult(result14); // @output 5<br><br>    printResult(result15); // @output -21474836<br>    printResult(result16); // @output -21475288<br>    printResult(result17); // @output 100<br>    printResult(result18); // @output 4<br>    printResult(result19); // @output 20712<br>    printResult(result20); // @output 236<br><br>    printResult(result21); // @output -454<br>    printResult(result22); // @output 32<br>    printResult(result23); // @output 21474832<br>    printResult(result24); // @output 54330<br>    printResult(result25); // @output 58<br><br>    printResult(result26); // @output 100<br>    printResult(result27); // @output 4<br>    printResult(result28); // @output 96<br>    printResult(result29); // @output 100<br><br>    printResult(result30); // @output 21474836<br>    printResult(result31); // @output 33808<br>    printResult(result32); // @output 20<br><br>    printResult(result33); // @output 54522<br>    printResult(result34); // @output 250<br><br>    printResult(result35); // @output 255<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil lifting for bitwise and operator at module level.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, <br>        int:Unsigned16, int:Unsigned32, module-init-var-decl, numeric-nil-lifting, optional-type, unary-minus<br><br>int? a = 43;<br><br>byte? b = 5;<br><br>int:Signed32? c = -21474836;<br>int:Signed16? d = -454;<br>int:Signed8? e = 100;<br><br>int:Unsigned32? f = 21474836;<br>int:Unsigned16? g = 54522;<br>int:Unsigned8? h = 255;<br><br>int? result1 = a & b;<br>int? result2 = a & c;<br>int? result3 = a & d;<br>int? result4 = a & e;<br>int? result5 = a & f;<br>int? result6 = a & g;<br>int? result7 = a & h;<br><br>int? result8 = b & b;<br>int? result9 = b & c;<br>int? result10 = b & d;<br>int? result11 = b & e;<br>int? result12 = b & f;<br>int? result13 = b & g;<br>int? result14 = b & h;<br><br>int? result15 = c & c;<br>int? result16 = c & d;<br>int? result17 = c & e;<br>int? result18 = c & f;<br>int? result19 = c & g;<br>int? result20 = c & h;<br><br>int? result21 = d & d;<br>int? result22 = d & e;<br>int? result23 = d & f;<br>int? result24 = d & g;<br>int? result25 = d & h;<br><br>int? result26 = e & e;<br>int? result27 = e & f;<br>int? result28 = e & g;<br>int? result29 = e & h;<br><br>int? result30 = f & f;<br>int? result31 = f & g;<br>int? result32 = f & h;<br><br>int? result33 = g & g;<br>int? result34 = g & h;<br><br>int? result35 = h & h;<br><br>function init() {<br>    printResult(result1); // @output 1<br>    printResult(result2); // @output 40<br>    printResult(result3); // @output 42<br>    printResult(result4); // @output 32<br>    printResult(result5); // @output 0<br>    printResult(result6); // @output 42<br>    printResult(result7); // @output 43<br><br>    printResult(result8); // @output 5<br>    printResult(result9); // @output 4<br>    printResult(result10); // @output 0<br>    printResult(result11); // @output 4<br>    printResult(result12); // @output 4<br>    printResult(result13); // @output 0<br>    printResult(result14); // @output 5<br><br>    printResult(result15); // @output -21474836<br>    printResult(result16); // @output -21475288<br>    printResult(result17); // @output 100<br>    printResult(result18); // @output 4<br>    printResult(result19); // @output 20712<br>    printResult(result20); // @output 236<br><br>    printResult(result21); // @output -454<br>    printResult(result22); // @output 32<br>    printResult(result23); // @output 21474832<br>    printResult(result24); // @output 54330<br>    printResult(result25); // @output 58<br><br>    printResult(result26); // @output 100<br>    printResult(result27); // @output 4<br>    printResult(result28); // @output 96<br>    printResult(result29); // @output 100<br><br>    printResult(result30); // @output 21474836<br>    printResult(result31); // @output 33808<br>    printResult(result32); // @output 20<br><br>    printResult(result33); // @output 54522<br>    printResult(result34); // @output 250<br><br>    printResult(result35); // @output 255<br>}<br><br>function printResult(int? result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test field access and optional field access expression as operands.<br>Labels: binary-bitwise-expr, int, module-type-defn, field-access-expr, mapping-constructor-expr, <br>        numeric-nil-lifting, optional-field-access-expr, optional-type, record-type<br><br>type Person record {|<br>    int id;<br>    int age?;<br>|};<br><br>function init() {<br>    Person p1 = {id: 33, age: 54};<br>    Person p2 = {id: 21, age: 23};<br><br>    printResult(p1.id & p2.id); // @output 1<br><br>    printResult(p1?.age & p2?.age); // @output 22<br><br>    printResult(p1.id & p2?.age); // @output 1<br>}<br><br>function printResult(int? result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test method call expression as operands.<br>Labels: binary-bitwise-expr, implicit-new-expr, int, method-call-expr, module-class-defn<br><br>class Car {<br>    function getCurrentSpeed() returns int {<br>        return 56;<br>    }<br><br>    function getRimSize() returns int {<br>        return 18;<br>    }<br>}<br><br>function init() {<br>    Car c1 = new;<br>    printResult(c1.getCurrentSpeed() & c1.getCurrentSpeed()); // @output 56<br>    printResult(c1.getCurrentSpeed() & c1.getRimSize()); // @output 16<br>    printResult(53 & c1.getRimSize()); // @output 16<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test check expression as operands.<br>Labels: binary-bitwise-expr, check, checkpanic, DecimalNumber, error-type, if-else-stmt, int, optional-type<br><br>function init() returns error? {<br>    printResult(check getData(4) & 5); // @output 4<br>    printResult(5 & check getData(4)); // @output 4<br>    printResult(check getData(52) & check getData(52)); // @output 52<br><br>    printResult(checkpanic getData(4) & 5); // @output 4<br>    printResult(5 & checkpanic getData(4)); // @output 4<br>    printResult(checkpanic getData(52) & checkpanic getData(52)); // @output 52<br>}<br><br>function getData(int? data) returns int|error {<br>    if data is int {<br>        return data;<br>    } else {<br>        return error("No data");<br>    }<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}</pre>
<h3>binary_bitwise_xor_expr.balt</h3>
<pre>Test-Case: output<br>Description: Test applying binary bitwise xor operation for value v with 0 results in the same value v.<br>Labels: binary-bitwise-expr, DecimalNumber, int, signed-zero, unary-minus, unary-plus<br><br>function init() {<br>    int a = 53443;<br>    int b = 0;<br>    int c = +0;<br>    int d = -0;<br><br>    io:println(543434344 ^ 0); // @output 543434344<br>    io:println(0 ^ 787654322); // @output 787654322<br>    io:println(-9223372036854775808 ^ 0); // @output -9223372036854775808<br>    io:println(0 ^ 0); // @output 0<br>    io:println(0 ^ a); // @output 53443<br>    io:println(a ^ 0); // @output 53443<br>    io:println(a ^ b); // @output 53443<br>    io:println(b ^ 64535654); // @output 64535654<br>    io:println(b ^ b); // @output 0<br>    io:println(-4434353 ^ b); // @output -4434353<br>    io:println(94434843 ^ c); // @output 94434843<br>    io:println(-6534353 ^ d); // @output -6534353<br>    io:println(c ^ c); // @output 0<br>    io:println(d ^ d); // @output 0<br>    io:println(-0 ^ -0); // @output 0<br>    io:println(+0 ^ +0); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test bitwise xor expression always evaluates to value 0 when the value of both operands are the same.<br>Labels: binary-bitwise-expr, DecimalNumber, int, unary-minus, unary-plus<br><br>function init() {<br>    int a = 99443;<br>    int b = 99443;<br>    int c = -223;<br><br>    io:println(543434343434 ^ 543434343434); // @output 0<br>    io:println(0 ^ 0); // @output 0<br>    io:println(a ^ a); // @output 0<br>    io:println(a ^ b); // @output 0<br>    io:println(b ^ a); // @output 0<br>    io:println(3 ^ 3); // @output 0<br>    io:println(-3 ^ -3); // @output 0<br>    io:println(c ^ c); // @output 0<br>    io:println(+987654321 ^ +987654321); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test if the type of both operands is a subtype of int:UnsignedK when K is 8, 16 or 32, then the static<br>             type of the result is int:UnsignedN where N is the smallest such K via inference.<br>Labels: binary-bitwise-expr, int:Unsigned8, int:Unsigned16, int:Unsigned32, var<br><br>function init() {<br>    int:Unsigned32 a = 5454;<br>    int:Unsigned16 b = 4344;<br>    var result1 = a ^ b;<br>    int:Unsigned32 c = result1;<br>    io:println(c); // @output 1462<br><br>    int:Unsigned8 d = 44;<br>    int:Unsigned16 e = 123;<br>    var result2 = d ^ e;<br>    int:Unsigned16 g = result2;<br>    io:println(g); // @output 87<br><br>    int:Unsigned32 h = 65;<br>    int:Unsigned8 i = 2;<br>    var result3 = h ^ i;<br>    int:Unsigned32 j = result3;<br>    io:println(j); // @output 67<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test if the type of both operands is a subtype of int:UnsignedK when K is 8, 16 or 32, then the static<br>             type of the result is int:UnsignedN where N is the smallest such K via invalid assignment with inference.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Unsigned8, int:Unsigned16, int:Unsigned32, var<br><br>function errorFunction() {<br>    int a = 4343;<br>    int b = 8;<br>    var result1 = a ^ b;<br>    int:Unsigned32 _ = result1; // @error the static type of the result is int<br><br>    int d = 9876;<br>    int:Unsigned32 e = 5454;<br>    var result2 = d ^ e;<br>    int:Unsigned16 _ = result2; // @error the static type of the result is int<br><br>    int g = 9876;<br>    int:Unsigned16 h = 5454;<br>    var result3 = g ^ h;<br>    int:Unsigned8 _ = result3; // @error the static type of the result is int<br><br>    byte _ = result3; // @error the static type of the result is int<br><br>    int:Signed8 k = 12;<br>    int:Signed16 m = 4434;<br>    var result4 = k ^ m;<br>    int:Signed8 _ = result4; // @error the static type of the result is int<br><br>    int:Unsigned16 n = 12;<br>    int:Unsigned16 p = 4434;<br>    var result5 = n ^ p;<br>    int:Signed16 _ = result5; // @error the static type of the result is Unsigned16<br><br>    int:Unsigned32 q = 12;<br>    int:Unsigned16 r = 4434;<br>    var result6 = q ^ r;<br>    int:Unsigned8 _ = result6; // @error the static type of the result is Unsigned32<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test bitwise xor expression evaluates to nil when either operand is nil.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, <br>        int:Unsigned16, int:Unsigned32, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>    int? a = 43;<br><br>    byte? b = 5;<br><br>    int:Signed32? c = -21474836;<br>    int:Signed16? d = -454;<br>    int:Signed8? e = 100;<br><br>    int:Unsigned32? f = 21474836;<br>    int:Unsigned16? g = 54522;<br>    int:Unsigned8? h = 255;<br><br>    int? i = ();<br>    byte? j = ();<br>    int:Signed32? k = ();<br>    int:Unsigned16? m = ();<br><br>    printResult(a ^ i); // @output ()<br>    printResult(a ^ j); // @output ()<br>    printResult(k ^ a); // @output ()<br>    printResult(m ^ a); // @output ()<br><br>    printResult(b ^ i); // @output ()<br>    printResult(b ^ j); // @output ()<br>    printResult(b ^ k); // @output ()<br>    printResult(b ^ m); // @output ()<br><br>    printResult(c ^ i); // @output ()<br>    printResult(c ^ j); // @output ()<br>    printResult(k ^ c); // @output ()<br>    printResult(c ^ m); // @output ()<br><br>    printResult(d ^ i); // @output ()<br>    printResult(d ^ j); // @output ()<br>    printResult(d ^ k); // @output ()<br>    printResult(d ^ m); // @output ()<br><br>    printResult(e ^ i); // @output ()<br>    printResult(e ^ j); // @output ()<br>    printResult(e ^ k); // @output ()<br>    printResult(e ^ m); // @output ()<br><br>    printResult(f ^ i); // @output ()<br>    printResult(f ^ j); // @output ()<br>    printResult(f ^ k); // @output ()<br>    printResult(f ^ m); // @output ()<br><br>    printResult(g ^ i); // @output ()<br>    printResult(g ^ j); // @output ()<br>    printResult(g ^ k); // @output ()<br>    printResult(g ^ m); // @output ()<br><br>    printResult(h ^ i); // @output ()<br>    printResult(h ^ j); // @output ()<br>    printResult(h ^ k); // @output ()<br>    printResult(h ^ m); // @output ()<br><br>    printResult(i ^ i); // @output ()<br>    printResult(i ^ j); // @output ()<br>    printResult(i ^ k); // @output ()<br>    printResult(i ^ m); // @output ()<br><br>    printResult(j ^ j); // @output ()<br>    printResult(j ^ k); // @output ()<br>    printResult(j ^ m); // @output ()<br><br>    printResult(k ^ k); // @output ()<br>    printResult(k ^ m); // @output ()<br><br>    printResult(m ^ m); // @output ()<br>}<br><br>function printResult(int? result) {<br>    io:println(result.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test the static type of bitwise or expression will be a nillable type when at least one operand is<br>             nillable via inference.<br>Labels: binary-bitwise-expr, byte, int, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, <br>        numeric-nil-lifting, optional-type, value:toBalString, var<br><br>function init() {<br>    int? a = 9876;<br>    int:Unsigned32 b = 5454;<br>    var c = a ^ b;<br>    int? result1 = c;<br>    io:println(result1); // @output 13274<br><br>    int:Unsigned16? d = 4344;<br>    var e = b ^ d;<br>    int:Unsigned32? result2 = e;<br>    io:println(result2); // @output 1462<br><br>    int:Unsigned8? f = 44;<br>    var g = d ^ f;<br>    int:Unsigned16? result3 = g;<br>    io:println(result3); // @output 4308<br><br>    var h = f ^ g;<br>    int:Unsigned16? result4 = h;<br>    io:println(result4); // @output 4344<br><br>    int i = 45343;<br>    int? j = 5454;<br>    int? result5 = i ^ j;<br>    io:println(result5); // @output 42065<br><br>    int m = 5454545343;<br>    byte? n = 43;<br>    int? result6 = m ^ n;<br>    io:println(result6); // @output 5454545300<br><br>    int p = 5454545343;<br>    byte? q = ();<br>    int? result7 = p ^ q;<br>    io:println(result7.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test the static type of bitwise xor expression will be a nillable type when at least one operand is <br>             nillable via inference and invalid assignments.<br>Labels: binary-bitwise-expr, byte, int, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, <br>        numeric-nil-lifting, optional-type, var<br><br>function errorFunction() {<br>    int? a = 9876;<br>    int:Unsigned32 b = 5454;<br>    var c = a ^ b;<br>    int _ = c; // @error the static type of the result is int?<br><br>    int:Unsigned16? d = 4344;<br>    var e = b ^ d;<br>    int:Unsigned32 _ = e; // @error the static type of the result is int:Unsigned32?<br><br>    int:Unsigned8? f = 44;<br>    var g = d ^ f;<br>    int:Unsigned16 _ = g; // @error the static type of the result is int:Unsigned16?<br><br>    var h = f ^ g;<br>    int:Unsigned16 _ = h; // @error the static type of the result is int:Unsigned16?<br><br>    int i = 45343;<br>    int? j = 5454;<br>    int _ = i ^ j; // @error the static type of the result is int?<br><br>    int m = 5454545343;<br>    byte? n = 43;<br>    int _ = m ^ n; // @error the static type of the result is int?<br><br>    int p = 5454545343;<br>    byte? q = ();<br>    int _ = p ^ q; // @error the static type of the result is int?<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test bitwise xor expression at module level.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8,<br>        int:Unsigned16, int:Unsigned32, module-init-var-decl, unary-minus<br><br>int a = 43;<br><br>byte b = 5;<br><br>int:Signed32 c = -21474836;<br>int:Signed16 d = -454;<br>int:Signed8 e = 100;<br><br>int:Unsigned32 f = 21474836;<br>int:Unsigned16 g = 54522;<br>int:Unsigned8 h = 255;<br><br>int result1 = a ^ b;<br>int result2 = a ^ c;<br>int result3 = a ^ d;<br>int result4 = a ^ e;<br>int result5 = a ^ f;<br>int result6 = a ^ g;<br>int result7 = a ^ h;<br><br>int result8 = b ^ b;<br>int result9 = b ^ c;<br>int result10 = b ^ d;<br>int result11 = b ^ e;<br>int result12 = b ^ f;<br>int result13 = b ^ g;<br>int result14 = b ^ h;<br><br>int result15 = c ^ c;<br>int result16 = c ^ d;<br>int result17 = c ^ e;<br>int result18 = c ^ f;<br>int result19 = c ^ g;<br>int result20 = c ^ h;<br><br>int result21 = d ^ d;<br>int result22 = d ^ e;<br>int result23 = d ^ f;<br>int result24 = d ^ g;<br>int result25 = d ^ h;<br><br>int result26 = e ^ e;<br>int result27 = e ^ f;<br>int result28 = e ^ g;<br>int result29 = e ^ h;<br><br>int result30 = f ^ f;<br>int result31 = f ^ g;<br>int result32 = f ^ h;<br><br>int result33 = g ^ g;<br>int result34 = g ^ h;<br><br>int result35 = h ^ h;<br><br>function init() {<br>    printResult(result1); // @output 46<br>    printResult(result2); // @output -21474873<br>    printResult(result3); // @output -495<br>    printResult(result4); // @output 79<br>    printResult(result5); // @output 21474879<br>    printResult(result6); // @output 54481<br>    printResult(result7); // @output 212<br><br>    printResult(result8); // @output 0<br>    printResult(result9); // @output -21474839<br>    printResult(result10); // @output -449<br>    printResult(result11); // @output 97<br>    printResult(result12); // @output 21474833<br>    printResult(result13); // @output 54527<br>    printResult(result14); // @output 250<br><br>    printResult(result15); // @output 0<br>    printResult(result16); // @output 21475286<br>    printResult(result17); // @output -21474936<br>    printResult(result18); // @output -8<br>    printResult(result19); // @output -21461738<br>    printResult(result20); // @output -21475053<br><br>    printResult(result21); // @output 0<br>    printResult(result22); // @output -418<br>    printResult(result23); // @output -21475282<br>    printResult(result24); // @output -54592<br>    printResult(result25); // @output -315<br><br>    printResult(result26); // @output 0<br>    printResult(result27); // @output 21474928<br>    printResult(result28); // @output 54430<br>    printResult(result29); // @output 155<br><br>    printResult(result30); // @output 0<br>    printResult(result31); // @output 21461742<br>    printResult(result32); // @output 21475051<br><br>    printResult(result33); // @output 0<br>    printResult(result34); // @output 54277<br><br>    printResult(result35); // @output 0<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil lifting for bitwise xor operator at module level.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, <br>        int:Unsigned16, int:Unsigned32, module-init-var-decl, numeric-nil-lifting, optional-type, unary-minus<br><br>int? a = 43;<br><br>byte? b = 5;<br><br>int:Signed32? c = -21474836;<br>int:Signed16? d = -454;<br>int:Signed8? e = 100;<br><br>int:Unsigned32? f = 21474836;<br>int:Unsigned16? g = 54522;<br>int:Unsigned8? h = 255;<br><br>int? result1 = a ^ b;<br>int? result2 = a ^ c;<br>int? result3 = a ^ d;<br>int? result4 = a ^ e;<br>int? result5 = a ^ f;<br>int? result6 = a ^ g;<br>int? result7 = a ^ h;<br><br>int? result8 = b ^ b;<br>int? result9 = b ^ c;<br>int? result10 = b ^ d;<br>int? result11 = b ^ e;<br>int? result12 = b ^ f;<br>int? result13 = b ^ g;<br>int? result14 = b ^ h;<br><br>int? result15 = c ^ c;<br>int? result16 = c ^ d;<br>int? result17 = c ^ e;<br>int? result18 = c ^ f;<br>int? result19 = c ^ g;<br>int? result20 = c ^ h;<br><br>int? result21 = d ^ d;<br>int? result22 = d ^ e;<br>int? result23 = d ^ f;<br>int? result24 = d ^ g;<br>int? result25 = d ^ h;<br><br>int? result26 = e ^ e;<br>int? result27 = e ^ f;<br>int? result28 = e ^ g;<br>int? result29 = e ^ h;<br><br>int? result30 = f ^ f;<br>int? result31 = f ^ g;<br>int? result32 = f ^ h;<br><br>int? result33 = g ^ g;<br>int? result34 = g ^ h;<br><br>int? result35 = h ^ h;<br><br>function init() {<br>    printResult(result1); // @output 46<br>    printResult(result2); // @output -21474873<br>    printResult(result3); // @output -495<br>    printResult(result4); // @output 79<br>    printResult(result5); // @output 21474879<br>    printResult(result6); // @output 54481<br>    printResult(result7); // @output 212<br><br>    printResult(result8); // @output 0<br>    printResult(result9); // @output -21474839<br>    printResult(result10); // @output -449<br>    printResult(result11); // @output 97<br>    printResult(result12); // @output 21474833<br>    printResult(result13); // @output 54527<br>    printResult(result14); // @output 250<br><br>    printResult(result15); // @output 0<br>    printResult(result16); // @output 21475286<br>    printResult(result17); // @output -21474936<br>    printResult(result18); // @output -8<br>    printResult(result19); // @output -21461738<br>    printResult(result20); // @output -21475053<br><br>    printResult(result21); // @output 0<br>    printResult(result22); // @output -418<br>    printResult(result23); // @output -21475282<br>    printResult(result24); // @output -54592<br>    printResult(result25); // @output -315<br><br>    printResult(result26); // @output 0<br>    printResult(result27); // @output 21474928<br>    printResult(result28); // @output 54430<br>    printResult(result29); // @output 155<br><br>    printResult(result30); // @output 0<br>    printResult(result31); // @output 21461742<br>    printResult(result32); // @output 21475051<br><br>    printResult(result33); // @output 0<br>    printResult(result34); // @output 54277<br><br>    printResult(result35); // @output 0<br>}<br><br>function printResult(int? result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test field access and optional field access expression as operands with type cast.<br>Labels: binary-bitwise-expr, int, module-type-defn, field-access-expr, mapping-constructor-expr, <br>        numeric-nil-lifting, optional-field-access-expr, optional-type, record-type<br><br>type Person record {|<br>    int id;<br>    int age?;<br>|};<br><br>function init() {<br>    Person p1 = {id: 33, age: 54};<br>    Person p2 = {id: 21, age: 23};<br><br>    printResult(p1.id ^ p2.id); // @output 52<br><br>    printResult(<int>p1?.age ^ <int>p2?.age); // @output 33<br><br>    printResult(p1.id ^ <int>p2?.age); // @output 54<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test method call expression as operands.<br>Labels: binary-bitwise-expr, implicit-new-expr, int, method-call-expr, module-class-defn<br><br>class Car {<br>    function getCurrentSpeed() returns int {<br>        return 56;<br>    }<br><br>    function getRimSize() returns int {<br>        return 18;<br>    }<br>}<br><br>function init() {<br>    Car c1 = new;<br>    printResult(c1.getCurrentSpeed() ^ c1.getCurrentSpeed()); // @output 0<br>    printResult(c1.getCurrentSpeed() ^ c1.getRimSize()); // @output 42<br>    printResult(53 ^ c1.getRimSize()); // @output 39<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test check expression as operands.<br>Labels: binary-bitwise-expr, check, checkpanic, DecimalNumber, error-type, if-else-stmt, int, optional-type<br><br>function init() returns error? {<br>    printResult(check getData(4) ^ 5); // @output 1<br>    printResult(5 ^ check getData(4)); // @output 1<br>    printResult(check getData(52) ^ check getData(52)); // @output 0<br><br>    printResult(checkpanic getData(4) ^ 5); // @output 1<br>    printResult(5 ^ checkpanic getData(4)); // @output 1<br>    printResult(checkpanic getData(52) ^ checkpanic getData(52)); // @output 0<br>}<br><br>function getData(int? data) returns int|error {<br>    if data is int {<br>        return data;<br>    } else {<br>        return error("No data");<br>    }<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}</pre>
<h3>binary_bitwise_or_expr.balt</h3>
<pre>Test-Case: output<br>Description: Test applying binary bitwise or operation for value v with 0 results in the same value v.<br>Labels: binary-bitwise-expr, DecimalNumber, int, signed-zero, unary-minus, unary-plus<br><br>function init() {<br>    int a = 53443;<br>    int b = 0;<br>    int c = +0;<br>    int d = -0;<br><br>    io:println(543434344 | 0); // @output 543434344<br>    io:println(0 | 787654322); // @output 787654322<br>    io:println(-9223372036854775808 | 0); // @output -9223372036854775808<br>    io:println(0 | 0); // @output 0<br>    io:println(0 | a); // @output 53443<br>    io:println(a | 0); // @output 53443<br>    io:println(a | b); // @output 53443<br>    io:println(b | 64535654); // @output 64535654<br>    io:println(b | b); // @output 0<br>    io:println(-4434353 | b); // @output -4434353<br>    io:println(94434843 | c); // @output 94434843<br>    io:println(-6534353 | d); // @output -6534353<br>    io:println(c | c); // @output 0<br>    io:println(d | d); // @output 0<br>    io:println(-0 | -0); // @output 0<br>    io:println(+0 | +0); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test bitwise or expression always evaluates to value v when the value of both operands are v.<br>Labels: binary-bitwise-expr, DecimalNumber, int, unary-minus, unary-plus<br><br>function init() {<br>    int a = 99443;<br>    int b = 99443;<br>    int c = -223;<br><br>    io:println(543434343434 | 543434343434); // @output 543434343434<br>    io:println(0 | 0); // @output 0<br>    io:println(a | a); // @output 99443<br>    io:println(a | b); // @output 99443<br>    io:println(b | a); // @output 99443<br>    io:println(3 | 3); // @output 3<br>    io:println(-3 | -3); // @output -3<br>    io:println(c | c); // @output -223<br>    io:println(+987654321 | +987654321); // @output 987654321<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test if the type of both operands is a subtype of int:UnsignedK when K is 8, 16 or 32, then the static<br>             type of the result is int:UnsignedN where N is the smallest such K via inference.<br>Labels: binary-bitwise-expr, int:Unsigned8, int:Unsigned16, int:Unsigned32, var<br><br>function init() {<br>    int:Unsigned32 a = 5454;<br>    int:Unsigned16 b = 4344;<br>    var result1 = a | b;<br>    int:Unsigned32 c = result1;<br>    io:println(c); // @output 5630<br><br>    int:Unsigned8 d = 44;<br>    int:Unsigned16 e = 123;<br>    var result2 = d | e;<br>    int:Unsigned16 g = result2;<br>    io:println(g); // @output 127<br><br>    int:Unsigned32 h = 65;<br>    int:Unsigned8 i = 2;<br>    var result3 = h | i;<br>    int:Unsigned32 j = result3;<br>    io:println(j); // @output 67<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test if the type of both operands is a subtype of int:UnsignedK when K is 8, 16 or 32, then the static<br>             type of the result is int:UnsignedN where N is the smallest such K via invalid assignment with inference.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Unsigned8, int:Unsigned16, int:Unsigned32, var<br><br>function errorFunction() {<br>    int a = 4343;<br>    int b = 8;<br>    var result1 = a | b;<br>    int:Unsigned32 _ = result1; // @error the static type of the result is int<br><br>    int d = 9876;<br>    int:Unsigned32 e = 5454;<br>    var result2 = d | e;<br>    int:Unsigned16 _ = result2; // @error the static type of the result is int<br><br>    int g = 9876;<br>    int:Unsigned16 h = 5454;<br>    var result3 = g | h;<br>    int:Unsigned8 _ = result3; // @error the static type of the result is int<br><br>    byte _ = result3; // @error the static type of the result is int<br><br>    int:Signed8 k = 12;<br>    int:Signed16 m = 4434;<br>    var result4 = k | m;<br>    int:Signed8 _ = result4; // @error the static type of the result is int<br><br>    int:Unsigned16 n = 12;<br>    int:Unsigned16 p = 4434;<br>    var result5 = n | p;<br>    int:Signed16 _ = result5; // @error the static type of the result is Unsigned16<br><br>    int:Unsigned32 q = 12;<br>    int:Unsigned16 r = 4434;<br>    var result6 = q | r;<br>    int:Unsigned8 _ = result6; // @error the static type of the result is Unsigned32<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test bitwise or expression evaluates to nil when either operand is nil.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, <br>        int:Unsigned16, int:Unsigned32, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>    int? a = 43;<br><br>    byte? b = 5;<br><br>    int:Signed32? c = -21474836;<br>    int:Signed16? d = -454;<br>    int:Signed8? e = 100;<br><br>    int:Unsigned32? f = 21474836;<br>    int:Unsigned16? g = 54522;<br>    int:Unsigned8? h = 255;<br><br>    int? i = ();<br>    byte? j = ();<br>    int:Signed32? k = ();<br>    int:Unsigned16? m = ();<br><br>    printResult(a | i); // @output ()<br>    printResult(a | j); // @output ()<br>    printResult(k | a); // @output ()<br>    printResult(m | a); // @output ()<br><br>    printResult(b | i); // @output ()<br>    printResult(b | j); // @output ()<br>    printResult(b | k); // @output ()<br>    printResult(b | m); // @output ()<br><br>    printResult(c | i); // @output ()<br>    printResult(c | j); // @output ()<br>    printResult(k | c); // @output ()<br>    printResult(c | m); // @output ()<br><br>    printResult(d | i); // @output ()<br>    printResult(d | j); // @output ()<br>    printResult(d | k); // @output ()<br>    printResult(d | m); // @output ()<br><br>    printResult(e | i); // @output ()<br>    printResult(e | j); // @output ()<br>    printResult(e | k); // @output ()<br>    printResult(e | m); // @output ()<br><br>    printResult(f | i); // @output ()<br>    printResult(f | j); // @output ()<br>    printResult(f | k); // @output ()<br>    printResult(f | m); // @output ()<br><br>    printResult(g | i); // @output ()<br>    printResult(g | j); // @output ()<br>    printResult(g | k); // @output ()<br>    printResult(g | m); // @output ()<br><br>    printResult(h | i); // @output ()<br>    printResult(h | j); // @output ()<br>    printResult(h | k); // @output ()<br>    printResult(h | m); // @output ()<br><br>    printResult(i | i); // @output ()<br>    printResult(i | j); // @output ()<br>    printResult(i | k); // @output ()<br>    printResult(i | m); // @output ()<br><br>    printResult(j | j); // @output ()<br>    printResult(j | k); // @output ()<br>    printResult(j | m); // @output ()<br><br>    printResult(k | k); // @output ()<br>    printResult(k | m); // @output ()<br><br>    printResult(m | m); // @output ()<br>}<br><br>function printResult(int? result) {<br>    io:println(result.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test the static type of bitwise or expression will be a nillable type when at least one operand is<br>             nillable via inference.<br>Labels: binary-bitwise-expr, byte, int, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, <br>        numeric-nil-lifting, optional-type, value:toBalString, var<br>       <br>function init() {<br>    int? a = 9876;<br>    int:Unsigned32 b = 5454;<br>    var c = a | b;<br>    int? result1 = c;<br>    io:println(result1); // @output 14302<br><br>    int:Unsigned16? d = 4344;<br>    var e = b | d;<br>    int:Unsigned32? result2 = e;<br>    io:println(result2); // @output 5630<br><br>    int:Unsigned8? f = 44;<br>    var g = d | f;<br>    int:Unsigned16? result3 = g;<br>    io:println(result3); // @output 4348<br><br>    var h = f | g;<br>    int:Unsigned16? result4 = h;<br>    io:println(result4); // @output 4348<br><br>    int i = 45343;<br>    int? j = 5454;<br>    int? result5 = i | j;<br>    io:println(result5); // @output 46431<br><br>    int m = 5454545343;<br>    byte? p = 43;<br>    int? result6 = m | p;<br>    io:println(result6); // @output 5454545343<br><br>    int q = 5454545343;<br>    byte? r = ();<br>    int? result7 = q | r;<br>    io:println(result7.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test the static type of bitwise or expression will be a nillable type when at least one operand is nillable<br>             via inference and invalid assignments.<br>Labels: binary-bitwise-expr, byte, int, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, <br>        numeric-nil-lifting, optional-type, var<br><br>function errorFunction() {<br>    int? a = 9876;<br>    int:Unsigned32 b = 5454;<br>    var c = a | b;<br>    int _ = c; // @error the static type of the result is int?<br><br>    int:Unsigned16? d = 4344;<br>    var e = b | d;<br>    int:Unsigned32 _ = e; // @error the static type of the result is int:Unsigned32?<br><br>    int:Unsigned8? f = 44;<br>    var g = d | f;<br>    int:Unsigned16 _ = g; // @error the static type of the result is int:Unsigned16?<br><br>    var h = f | g;<br>    int:Unsigned16 _ = h; // @error the static type of the result is int:Unsigned16?<br><br>    int i = 45343;<br>    int? j = 5454;<br>    int _ = i | j; // @error the static type of the result is int?<br><br>    int m = 5454545343;<br>    byte? n = 43;<br>    int _ = m | n; // @error the static type of the result is int?<br><br>    int p = 5454545343;<br>    byte? q = ();<br>    int _ = p | q; // @error the static type of the result is int?<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test bitwise or expression at module level.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, <br>        int:Unsigned16, int:Unsigned32, module-init-var-decl, unary-minus<br><br>int a = 43;<br><br>byte b = 5;<br><br>int:Signed32 c = -21474836;<br>int:Signed16 d = -454;<br>int:Signed8 e = 100;<br><br>int:Unsigned32 f = 21474836;<br>int:Unsigned16 g = 54522;<br>int:Unsigned8 h = 255;<br><br>int result1 = a | b;<br>int result2 = a | c;<br>int result3 = a | d;<br>int result4 = a | e;<br>int result5 = a | f;<br>int result6 = a | g;<br>int result7 = a | h;<br><br>int result8 = b | b;<br>int result9 = b | c;<br>int result10 = b | d;<br>int result11 = b | e;<br>int result12 = b | f;<br>int result13 = b | g;<br>int result14 = b | h;<br><br><br>int result15 = c | c;<br>int result16 = c | d;<br>int result17 = c | e;<br>int result18 = c | f;<br>int result19 = c | g;<br>int result20 = c | h;<br><br>int result21 = d | d;<br>int result22 = d | e;<br>int result23 = d | f;<br>int result24 = d | g;<br>int result25 = d | h;<br><br>int result26 = e | e;<br>int result27 = e | f;<br>int result28 = e | g;<br>int result29 = e | h;<br><br>int result30 = f | f;<br>int result31 = f | g;<br>int result32 = f | h;<br><br>int result33 = g | g;<br>int result34 = g | h;<br><br>int result35 = h | h;<br><br>function init() {<br>    printResult(result1); // @output 47<br>    printResult(result2); // @output -21474833<br>    printResult(result3); // @output -453<br>    printResult(result4); // @output 111<br>    printResult(result5); // @output 21474879<br>    printResult(result6); // @output 54523<br>    printResult(result7); // @output 255<br><br>    printResult(result8); // @output 5<br>    printResult(result9); // @output -21474835<br>    printResult(result10); // @output -449<br>    printResult(result11); // @output 101<br>    printResult(result12); // @output 21474837<br>    printResult(result13); // @output 54527<br>    printResult(result14); // @output 255<br><br>    printResult(result15); // @output -21474836<br>    printResult(result16); // @output -2<br>    printResult(result17); // @output -21474836<br>    printResult(result18); // @output -4<br>    printResult(result19); // @output -21441026<br>    printResult(result20); // @output -21474817<br><br>    printResult(result21); // @output -454<br>    printResult(result22); // @output -386<br>    printResult(result23); // @output -450<br>    printResult(result24); // @output -262<br>    printResult(result25); // @output -257<br><br>    printResult(result26); // @output 100<br>    printResult(result27); // @output 21474932<br>    printResult(result28); // @output 54526<br>    printResult(result29); // @output 255<br><br>    printResult(result30); // @output 21474836<br>    printResult(result31); // @output 21495550<br>    printResult(result32); // @output 21475071<br><br>    printResult(result33); // @output 54522<br>    printResult(result34); // @output 54527<br><br>    printResult(result35); // @output 255<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil lifting for bitwise or operator at module level.<br>Labels: binary-bitwise-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, <br>        int:Unsigned16, int:Unsigned32, numeric-nil-lifting, optional-type, unary-minus<br><br>int? a = 43;<br><br>byte? b = 5;<br><br>int:Signed32? c = -21474836;<br>int:Signed16? d = -454;<br>int:Signed8? e = 100;<br><br>int:Unsigned32? f = 21474836;<br>int:Unsigned16? g = 54522;<br>int:Unsigned8? h = 255;<br><br>int? result1 = a | b;<br>int? result2 = a | c;<br>int? result3 = a | d;<br>int? result4 = a | e;<br>int? result5 = a | f;<br>int? result6 = a | g;<br>int? result7 = a | h;<br><br>int? result8 = b | b;<br>int? result9 = b | c;<br>int? result10 = b | d;<br>int? result11 = b | e;<br>int? result12 = b | f;<br>int? result13 = b | g;<br>int? result14 = b | h;<br><br>int? result15 = c | c;<br>int? result16 = c | d;<br>int? result17 = c | e;<br>int? result18 = c | f;<br>int? result19 = c | g;<br>int? result20 = c | h;<br><br>int? result21 = d | d;<br>int? result22 = d | e;<br>int? result23 = d | f;<br>int? result24 = d | g;<br>int? result25 = d | h;<br><br>int? result26 = e | e;<br>int? result27 = e | f;<br>int? result28 = e | g;<br>int? result29 = e | h;<br><br>int? result30 = f | f;<br>int? result31 = f | g;<br>int? result32 = f | h;<br><br>int? result33 = g | g;<br>int? result34 = g | h;<br><br>int? result35 = h | h;<br><br>function init() {<br>    printResult(result1); // @output 47<br>    printResult(result2); // @output -21474833<br>    printResult(result3); // @output -453<br>    printResult(result4); // @output 111<br>    printResult(result5); // @output 21474879<br>    printResult(result6); // @output 54523<br>    printResult(result7); // @output 255<br><br>    printResult(result8); // @output 5<br>    printResult(result9); // @output -21474835<br>    printResult(result10); // @output -449<br>    printResult(result11); // @output 101<br>    printResult(result12); // @output 21474837<br>    printResult(result13); // @output 54527<br>    printResult(result14); // @output 255<br><br>    printResult(result15); // @output -21474836<br>    printResult(result16); // @output -2<br>    printResult(result17); // @output -21474836<br>    printResult(result18); // @output -4<br>    printResult(result19); // @output -21441026<br>    printResult(result20); // @output -21474817<br><br>    printResult(result21); // @output -454<br>    printResult(result22); // @output -386<br>    printResult(result23); // @output -450<br>    printResult(result24); // @output -262<br>    printResult(result25); // @output -257<br><br>    printResult(result26); // @output 100<br>    printResult(result27); // @output 21474932<br>    printResult(result28); // @output 54526<br>    printResult(result29); // @output 255<br><br>    printResult(result30); // @output 21474836<br>    printResult(result31); // @output 21495550<br>    printResult(result32); // @output 21475071<br><br>    printResult(result33); // @output 54522<br>    printResult(result34); // @output 54527<br><br>    printResult(result35); // @output 255<br>}<br><br>function printResult(int? result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test field access and optional field access expression as operands with type cast.<br>Labels: binary-bitwise-expr, int, module-type-defn, field-access-expr, mapping-constructor-expr, <br>        numeric-nil-lifting, optional-field-access-expr, optional-type, record-type<br><br>type Person record {|<br>    int id;<br>    int age?;<br>|};<br><br>function init() {<br>    Person p1 = {id: 33, age: 54};<br>    Person p2 = {id: 21, age: 23};<br><br>    printResult(p1.id | p2.id); // @output 53<br><br>    printResult(<int>p1?.age | <int>p2?.age); // @output 55<br><br>    printResult(p1.id | <int>p2?.age); // @output 55<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test method call expression as operands.<br>Labels: binary-bitwise-expr, implicit-new-expr, int, method-call-expr, module-class-defn<br><br>class Car {<br>    function getCurrentSpeed() returns int {<br>        return 56;<br>    }<br><br>    function getRimSize() returns int {<br>        return 18;<br>    }<br>}<br><br>function init() {<br>    Car c1 = new;<br>    printResult(c1.getCurrentSpeed() | c1.getCurrentSpeed()); // @output 56<br>    printResult(c1.getCurrentSpeed() | c1.getRimSize()); // @output 58<br>    printResult(53 | c1.getRimSize()); // @output 55<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test check expression as operands.<br>Labels: binary-bitwise-expr, check, checkpanic, DecimalNumber, error-type, if-else-stmt, int, optional-type<br><br>function init() returns error? {<br>    printResult(check getData(4) | 5); // @output 5<br>    printResult(5 | check getData(4)); // @output 5<br>    printResult(check getData(52) | check getData(52)); // @output 52<br><br>    printResult(checkpanic getData(4) | 5); // @output 5<br>    printResult(5 | checkpanic getData(4)); // @output 5<br>    printResult(checkpanic getData(52) | checkpanic getData(52)); // @output 52<br>}<br><br>function getData(int? data) returns int|error {<br>    if data is int {<br>        return data;<br>    } else {<br>        return error("No data");<br>    }<br>}<br><br>function printResult(int result) {<br>    io:println(result);<br>}</pre>
<h3>string_literal.balt</h3>
<pre>Test-Case: output<br>Description: Test empty string value.<br>Labels: string, value:toBalString<br><br>function init() {<br>    string a = "";<br>    io:println(a.toBalString()); // @output ""<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test type mismatch when assigning string literal to variables of type T,<br>             where string is not a sub type of T.<br>Labels: byte, float, nil-type, string, xml<br><br>function errorFunction() {<br>    int _ = "String"; // @error string literal cannot be assigned to a variable of int<br><br>    xml _ = ""; // @error string literal cannot be assigned to a variable of xml<br><br>    () _ = ""; // @error string literal cannot be assigned to a variable of nil<br><br>    byte _ = "c"; // @error string literal cannot be assigned to a variable of byte<br><br>    float _ = "44.5"; // @error string literal cannot be assigned to a variable of float<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string literal in defaultable parameter context.<br>Labels: function-call-expr, function-defn, defaultable-param, string<br><br>function init() {<br>    printString("6564"); // @output 6564<br>    printString(); // @output Default<br>}<br><br>function printString(string str = "Default") {<br>    io:println(str);<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string literal in method call expression context.<br>Labels: method-call-expr, string<br><br>function init() {<br>    io:println("some".startsWith("s")); // @output true<br><br>    io:println("Hello World".substring(6)); // @output World<br><br>    io:println("ABCD".toLowerAscii()); // @output abcd<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string literal in match expression context.<br>Labels: match-stmt, string, var<br><br>function init() {<br>    match "Ballerina" {<br>        var a => {<br>            io:println(a); // @output Ballerina<br>        }<br>    }<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string literal in structural constructor context.<br>Labels: list-constructor-expr, mapping-constructor-expr, string, table-constructor-expr<br><br>function init() {<br>    io:println(["1221", "Ballerina"]); // @output ["1221","Ballerina"]<br><br>    io:println({name: "Mike", age: "54", "rest": "restData"}); // @output {"name":"Mike","age":"54","rest":"restData"}<br><br>    io:println(table [{id: "003", name: "Mike", age: "54"}]); // @output [{"id":"003","name":"Mike","age":"54"}]<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string literal in member access expression context.<br>Labels: member-access-expr, string<br><br>function init() {<br>    io:println("Banana"[0]); // @output B<br><br>    io:println("564545"[1]); // @output 6<br><br>    io:println("r4\u{0065}"[2]); // @output e<br>}</pre>
<h3>nil_literal.balt</h3>
<pre>Test-Case: output<br>Description: Test nil literal '()' with nil type descriptor and toBalString().<br>Labels: nil-literal, nil-type, value:toBalString<br><br>public function main() {<br>    () x = ();<br>    io:println(x.toBalString()); // @output ()<br><br>    io:println(().toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal 'null' with nil type descriptor and toBalString().<br>Labels: nil-type, null, value:toBalString<br><br>public function main() {<br>    () x = null;<br>    io:println(x.toBalString()); // @output ()<br><br>    io:println(null.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal '()' with toString().<br>Labels: nil-literal, nil-type, value:toString<br><br>public function main() {<br>    () x = ();<br>    io:println(x); // @output<br><br>    io:println(().toString()); // @output<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal 'null' with toString().<br>Labels: nil-type, null, value:toString<br><br>public function main() {<br>    () x = null;<br>    io:println(x); // @output<br><br>    io:println(null.toString()); // @output<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test different nil literal '()' representations with nil type descriptor.<br>Labels: nil-literal, nil-type, value:toBalString<br><br>public function main() {<br>    () x = ( );<br>    io:println(x.toBalString()); // @output ()<br><br>    x = (    );<br>    io:println(x.toBalString()); // @output ()<br><br>    x = (<br>    );<br>    io:println(x.toBalString()); // @output ()<br><br>    x = (());<br>    io:println(x.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test different nil literal 'null' representations with nil type descriptor.<br>Labels: nil-type, null, value:toBalString<br><br>public function main() {<br>    () x = (null);<br>    io:println(x.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal '()' with function call.<br>Labels: function-call-expr, nil-literal, nil-type, value:toBalString<br><br>public function main() {<br>    testNil(()); // @output ()<br>}<br><br>function testNil(() x) {<br>    io:println(x.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal 'null' with function call.<br>Labels: function-call-expr, nil-type, null, value:toBalString<br><br>public function main() {<br>    testNil(null); // @output ()<br>}<br><br>function testNil(() x) {<br>    io:println(x.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal '()' with valid type casts.<br>Labels: nil-literal, nil-type, type-cast-expr, value:toBalString<br><br>public function main() {<br>    io:println((<()> ()).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal 'null' with valid type casts.<br>Labels: nil-type, null, type-cast-expr, value:toBalString<br><br>public function main() {<br>    io:println((<()> null).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal '()' with interpolation in template expressions.<br>Labels: nil-literal, raw-template-expr<br><br>public function main() {<br>    io:println(`${()}`); // @output<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal 'null' with interpolation in template expressions.<br>Labels: null, raw-template-expr<br><br>public function main() {<br>    io:println(`${null}`); // @output<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literals as members of structural constructors.<br>Labels: list-constructor-expr, mapping-constructor-expr, nil-literal, null, value:toBalString<br><br>public function main() {<br>    io:println([(), null].toBalString()); // @output [(),()]<br><br>    io:println({"c" : (), "b" : null}.toBalString()); // @output {"c":(),"b":()}<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal '()' with return statement.<br>Labels: nil-literal, nil-type, return-stmt, value:toBalString<br><br>public function main() {<br>    io:println(testNil().toBalString()); // @output ()<br>}<br><br>function testNil() returns () {<br>    return ();<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal 'null' with return statement.<br>Labels: nil-type, null, return-stmt, value:toBalString<br><br>public function main() {<br>    io:println(testNil().toBalString()); // @output ()<br>}<br><br>function testNil() returns () {<br>    return null;<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal '()' with optional type descriptor.<br>Labels: boolean, decimal, float, int, nil-literal, optional-type, value:toBalString<br><br>public function main() {<br>    boolean? a = ();<br>    io:println(a.toBalString()); // @output ()<br><br>    decimal? b = ();<br>    io:println(b.toBalString()); // @output ()<br><br>    float? c = ();<br>    io:println(c.toBalString()); // @output ()<br><br>    int? d = ();<br>    io:println(d.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal 'null' with optional type descriptor.<br>Labels: boolean, decimal, float, int, null, optional-type, value:toBalString<br><br>public function main() {<br>    boolean? a = null;<br>    io:println(a.toBalString()); // @output ()<br><br>    decimal? b = null;<br>    io:println(b.toBalString()); // @output ()<br><br>    float? c = null;<br>    io:println(c.toBalString()); // @output ()<br><br>    int? d = null;<br>    io:println(d.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal 'null' with json type descriptor.<br>Labels: null, json, value:toBalString<br><br>public function main() {<br>    json x = null;<br>    io:println(x.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test nil literal '()' with json type descriptor.<br>Labels: nil-literal, json, value:toBalString<br><br>public function main() {<br>    json x = ();<br>    io:println(x.toBalString()); // @output ()<br>}<br></pre>
<h3>numeric_literal.balt</h3>
<pre>Test-Case: output<br>Description: Test the basic type when the numeric-literal is a HexFloatingPointLiteral.<br>Labels: any, decimal, float, HexFloatingPointLiteral, int, is-expr<br><br>function init() {<br>    any x = 0xabc12.def;<br>    io:println(x is int); // @output false<br>    io:println(x is float); // @output true<br>    io:println(x is decimal); // @output false<br><br>    x = 0x.2131ef;<br>    io:println(x is int); // @output false<br>    io:println(x is float); // @output true<br>    io:println(x is decimal); // @output false<br><br>    x = 0x123.456cP4;<br>    io:println(x is int); // @output false<br>    io:println(x is float); // @output true<br>    io:println(x is decimal); // @output false<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test the basic type when the numeric-literal is a HexFloatingPointLiteral, via incompatible assignment.<br>Labels: decimal, float, HexFloatingPointLiteral, int<br><br>function errorFunction() {<br>    decimal _ = 0xabc12.def; // @error expected an 'decimal' but found a 'float'<br><br>    decimal _ = 0x.2131ef; // @error expected an 'decimal' but found a 'float'<br><br>    int _ = 0x123.456cP4; // @error expected an 'int' but found a 'float'<br>}<br></pre>
<h3>int_literal.balt</h3>
<pre>Test-Case: output<br>Description: Test DecimalNumbers with toString().<br>Labels: DecimalNumber, value:toString<br><br>function init() {<br>    io:println((101).toString()); // @output 101<br><br>    io:println(0.toString()); // @output 0<br><br>    io:println(9223372036854775807.toString()); // @output 9223372036854775807<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test HexIntLiteral with toString().<br>Fail-Issue: ballerina-platform/ballerina-lang#32769<br>Labels: HexIntLiteral, value:toString<br><br>function init() {<br>    io:println(0x12ab.toString()); // @output 4779<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test DecimalNumbers with toBalString().<br>Labels: DecimalNumber, value:toBalString<br><br>function init() {<br>    io:println((101).toBalString()); // @output 101<br><br>    io:println(0.toBalString()); // @output 0<br><br>    io:println(9223372036854775807.toBalString()); // @output 9223372036854775807<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test HexIntLiteral with toBalString().<br>Fail-Issue: ballerina-platform/ballerina-lang#32769<br>Labels: HexIntLiteral, value:toBalString<br><br>function init() {<br>    io:println(0x12ab.toBalString()); // @output 4779<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test numeric value greater than upper bound for decimal.<br>Labels: DecimalNumber, decimal<br><br>function errorFunction() {<br>    decimal _ = 10092233720368547758081009223372036854775; // @error number '10092233720368547758081009223372036854775' is too large<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test int literals with interpolation in template expressions.<br>Labels: DecimalNumber, HexIntLiteral, raw-template-expr<br><br>function init() {<br>    io:println(`${124}`); // @output 124<br><br>    io:println(`${0x7ab1}`); // @output 31409<br>}<br></pre>
<h3>boolean_literal.balt</h3>
<pre>Test-Case: output<br>Description: Test boolean literals with toString().<br>Labels: boolean-literal, value:toString<br><br>public function main() {<br>    io:println(true.toString()); // @output true<br><br>    io:println(false.toString()); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test boolean literals with toBalString().<br>Labels: boolean-literal, value:toBalString<br><br>public function main() {<br>    io:println(true.toBalString()); // @output true<br><br>    io:println(false.toBalString()); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test boolean literals with interpolation in template expressions.<br>Labels: boolean-literal, raw-template-expr<br><br>public function main() {<br>    io:println(`${true}`); // @output true<br><br>    io:println(`${false}`); // @output false<br>}<br></pre>
<h3>unary_minus_expression.balt</h3>
<pre>Test-Case: panic<br>Description: Test unary negative overflow for int.<br>Fail-Issue: ballerina-platform/ballerina-lang#32922<br>Labels: additive-expr, DecimalNumber, int, unary-minus<br><br>function init() {<br>   int a = -9223372036854775807;<br>   int _ = -(a - 1); // @panic integer overflow on unary negative<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional integers with no overflow scenarios.<br>Labels: DecimalNumber, int, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int? a = 1;<br>   int? b = 101;<br>   int? c = 0;<br>   int? d = ();<br>   io:println(-a); // @output -1<br>   io:println(-b); // @output -101<br>   io:println(-c); // @output 0<br>   io:println((-d).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for negative optional integers with no overflow scenarios.<br>Labels: DecimalNumber, int, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int? a = -1;<br>   int? b = -101;<br>   int? c = ();<br>   io:println(-a); // @output 1<br>   io:println(-b); // @output 101<br>   io:println((-c).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional int:Unsigned8 with no overflow scenarios.<br>Labels: DecimalNumber, int:Unsigned8, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int:Unsigned8? a = 1;<br>   int:Unsigned8? b = 2;<br>   int:Unsigned8? c = ();<br>   int:Unsigned8? d = 255;<br><br>   io:println(-a); // @output -1<br>   io:println(-b); // @output -2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output -255<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional byte with no overflow scenarios.<br>Labels: byte, DecimalNumber, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   byte? a = 1;<br>   byte? b = 2;<br>   byte? c = ();<br>   byte? d = 255;<br><br>   io:println(-a); // @output -1<br>   io:println(-b); // @output -2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output -255<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional int:Unsigned16 with no overflow scenarios.<br>Labels: DecimalNumber, int:Unsigned16, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int:Unsigned16? a = 1;<br>   int:Unsigned16? b = 2;<br>   int:Unsigned16? c = ();<br>   int:Unsigned16? d = 65535;<br><br>   io:println(-a); // @output -1<br>   io:println(-b); // @output -2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output -65535<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional int:Unsigned32 with no overflow scenarios.<br>Labels: DecimalNumber, int:Unsigned32, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int:Unsigned32? a = 1;<br>   int:Unsigned32? b = 2;<br>   int:Unsigned32? c = ();<br>   int:Unsigned32? d = 429496729;<br><br>   io:println(-a); // @output -1<br>   io:println(-b); // @output -2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output -429496729<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional int:Signed8 with no overflow scenarios.<br>Labels: DecimalNumber, int:Signed8, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int:Signed8? a = 1;<br>   int:Signed8? b = 2;<br>   int:Signed8? c = ();<br>   int:Signed8? d = 127;<br><br>   io:println(-a); // @output -1<br>   io:println(-b); // @output -2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output -127<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for negative optional int:Signed8 with no overflow scenarios.<br>Labels: DecimalNumber, int:Signed8, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int:Signed8? a = -1;<br>   int:Signed8? b = -2;<br>   int:Signed8? c = ();<br>   int:Signed8? d = -128;<br><br>   io:println(-a); // @output 1<br>   io:println(-b); // @output 2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output 128<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional int:Signed16 with no overflow scenarios.<br>Labels: DecimalNumber, int:Signed16, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int:Signed16? a = 1;<br>   int:Signed16? b = 2;<br>   int:Signed16? c = ();<br>   int:Signed16? d = 32767;<br><br>   io:println(-a); // @output -1<br>   io:println(-b); // @output -2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output -32767<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for negative optional int:Signed16 with no overflow scenarios.<br>Labels: DecimalNumber, int:Signed16, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int:Signed16? a = -1;<br>   int:Signed16? b = -2;<br>   int:Signed16? c = ();<br>   int:Signed16? d = -32768;<br><br>   io:println(-a); // @output 1<br>   io:println(-b); // @output 2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output 32768<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional int:Signed32 with no overflow scenarios.<br>Labels: DecimalNumber, int:Signed32, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int:Signed32? a = 1;<br>   int:Signed32? b = 2;<br>   int:Signed32? c = ();<br>   int:Signed32? d = 2147483647;<br><br>   io:println(-a); // @output -1<br>   io:println(-b); // @output -2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output -2147483647<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for negative optional int:Signed32 with no overflow scenarios.<br>Labels: DecimalNumber, int:Signed32, nil-literal, numeric-nil-lifting, optional-type, unary-minus, value:toBalString<br><br>function init() {<br>   int:Signed32? a = -1;<br>   int:Signed32? b = -2;<br>   int:Signed32? c = ();<br>   int:Signed32? d = -2147483648;<br><br>   io:println(-a); // @output 1<br>   io:println(-b); // @output 2<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output 2147483648<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional user-defined sub-types of int with<br>             no overflow scenarios.<br>Labels: DecimalNumber, module-type-defn, numeric-nil-lifting, optional-type, singleton-type, unary-minus, union-type,<br>        value:toBalString<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>   Ints? a = 1;<br>   Ints? b = ();<br>   Ints? c = 0;<br><br>   io:println(-a); // @output -1<br>   io:println((-b).toBalString()); // @output ()<br>   io:println(-c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional floats with no overflow scenarios.<br>Labels: DecimalFloatingPointNumber, float, nil-literal, numeric-nil-lifting, optional-type, unary-minus,<br>        value:toBalString<br><br>function init() {<br>   float? a = 1.0;<br>   float? b = 101.5;<br>   float? c = ();<br>   float? d = 922439289.0;<br>   io:println(-a); // @output -1.0<br>   io:println(-b); // @output -101.5<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output -9.22439289E8<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for negative optional floats with no overflow scenarios.<br>Labels: DecimalFloatingPointNumber, float, nil-literal, numeric-nil-lifting, optional-type, unary-minus,<br>        value:toBalString<br><br>function init() {<br>   float? a = -1.0;<br>   float? b = ();<br>   float? c = -922439289.0;<br>   io:println(-a); // @output 1.0<br>   io:println((-b).toBalString()); // @output ()<br>   io:println(-c); // @output 9.22439289E8<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional user-defined sub-types of float with<br>             no overflow scenarios.<br>Labels: DecimalFloatingPointNumber, float, module-type-defn, numeric-nil-lifting, optional-type, singleton-type,<br>        unary-minus, union-type, value:toBalString<br><br>type Floats -2.0|-1.0|0.0|1.0|2.0;<br><br>function init() {<br>   Floats? a = 1.0;<br>   Floats? b = 2.0;<br>   Floats? c = ();<br><br>   io:println(-a); // @output -1.0<br>   io:println(-b); // @output -2.0<br>   io:println((-c).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for positive optional decimals with no overflow scenarios.<br>Labels: decimal, DecimalFloatingPointNumber, nil-literal, numeric-nil-lifting, optional-type, unary-minus,<br>        value:toBalString<br><br>function init() {<br>   decimal? a = 1.0;<br>   decimal? b = 101.5;<br>   decimal? c = ();<br>   decimal? d = 922439289.0;<br>   io:println(-a); // @output -1.0<br>   io:println(-b); // @output -101.5<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output -922439289.0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary negative expression for negative optional decimals with no overflow scenarios.<br>Labels: decimal, DecimalFloatingPointNumber, nil-literal, numeric-nil-lifting, optional-type, unary-minus,<br>        value:toBalString<br><br>function init() {<br>   decimal? a = -1.0;<br>   decimal? b = -101.5;<br>   decimal? c = ();<br>   decimal? d = -922439289.0;<br>   io:println(-a); // @output 1.0<br>   io:println(-b); // @output 101.5<br>   io:println((-c).toBalString()); // @output ()<br>   io:println(-d); // @output 922439289.0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test let expression in unary negation operands.<br>Labels: DecimalNumber, int, let-expr, unary-minus<br><br>function init() {<br>   int a = -(let int h1 = 3 * 4 in h1);<br>   io:println(a); // @output -12<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary expression as the operand of unary negation.<br>Labels: DecimalNumber, int, unary-complement, unary-minus, unary-plus<br><br>function init() {<br>   int a = 5;<br>   a = -+5;<br>   io:println(a); // @output -5<br><br>   a = 5;<br>   a = --5;<br>   io:println(a); // @output 5<br><br>   a = 5;<br>   a = -~5;<br>   io:println(a); // @output 6<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test conditional expressions as unary negative operands.<br>Labels: binary-conditional-expr, DecimalNumber, error-type, int, nil-literal, optional-type, ternary-conditional-expr,<br>        unary-minus, union-type<br><br>function init() {<br>   int|error a = 12;<br>   int? b = ();<br>   int c = -(a is error ? 2 : a);<br>   int d =  -(b ?: 13);<br>   io:println(c); // @output -12<br>   io:println(d); // @output -13<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test checking expressions as unary negative operands.<br>Labels: check, checkpanic, DecimalNumber, error-type, int, optional-type, unary-minus, union-type<br><br>function init() returns error? {<br>   int|error a = 12;<br>   int c = -check a;<br>   int d = -checkpanic a;<br>   io:println(c); // @output -12<br>   io:println(d); // @output -12<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test the static type of the result is the basic type of the static type of the operand, <br>           for int type operands via invalid assignment with inference.<br>Labels: decimal, float, int, unary-minus, var<br><br>function errorFunction(int a) {<br>   var a1 = -a;<br>   float _ = a1; // @error static type of unary-minus expression with int operands is int<br><br>   var a3 = -a;<br>   decimal _ = a3; // @error static type of unary-minus expression with int operands is int<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test the static type of the result is the basic type of the static type of the operand, <br>           for float type operands via invalid assignment with inference.<br>Labels: decimal, float, int, unary-minus, var<br><br>function errorFunction(float c) {<br>   var a1 = -c;<br>   int _ = a1; // @error static type of unary-minus expression with float operands is float<br><br>   var a3 = -c;<br>   decimal _ = a3; // @error static type of unary-minus expression with float operands is float<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test the static type of the result is the basic type of the static type of the operand, <br>           for decimal type operands via invalid assignment with inference.<br>Labels: decimal, float, int, unary-minus, var<br><br>function errorFunction(decimal c) {<br>   var a1 = -c;<br>   int _ = a1; // @error static type of unary-minus expression with decimal operands is decimal<br><br>   var a3 = -c;<br>   float _ = a3; // @error static type of unary-minus expression with decimal operands is decimal<br>}<br></pre>
<h3>multiplicative_expr.balt</h3>
<pre>Test-Case: error<br>Description: Test for int the static type of the result being the basic type of the operands via invalid assignment<br>             with inference, where operands are of numeric types.<br>Labels: multiplicative-expr, int, float, decimal, var, DecimalNumber<br><br>function errorFunction(int a, int b) {<br>    var a1 = a * b;<br>    float _ = a1; // @error static type of multiplicative-expr with int operands is int<br><br>    var a3 = a / a;<br>    decimal _ = a3; // @error static type of multiplicative-expr with int operands is int<br><br>    var a5 = 1 % b;<br>    float _ = a5; // @error static type of multiplicative-expr with int operands is int<br><br>    var a7 = getInt(12 * 2) * b;<br>    float _ = a7; // @error static type of multiplicative-expr with int operands is int<br>}<br><br>function getInt(int i) returns int {<br>    return i * 1;<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test for float the static type of the result being the basic type of the operands via invalid assignment<br>             with inference, where operands are of numeric types.<br>Labels: multiplicative-expr, int, float, decimal, var, DecimalFloatingPointNumber<br><br>function errorFunction(float c, float d) {<br>    var a1 = 2.0 * 2.1;<br>    int _ = a1; // @error static type of multiplicative-expr with float operands is float<br><br>    var a3 = c / d;<br>    decimal _ = a3; // @error static type of multiplicative-expr with float operands is float<br><br>    var a5 = d % d;<br>    int _ = a5; // @error static type of multiplicative-expr with float operands is float<br>    <br>    var a7 = d % (getFloat(getFloat(2.0 / c)));<br>    int _ = a7; // @error static type of multiplicative-expr with float operands is float<br>}<br><br>function getFloat(float f) returns float {<br>    return f / 1f;<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test for decimal the static type of the result being the basic type of the operands via invalid assignment<br>             with inference, where operands are of numeric types.<br>Labels: multiplicative-expr, int, float, decimal, var, DecimalFloatingPointNumber<br><br>function errorFunction(decimal e, decimal f) {<br>    var a1 = e * e;<br>    float _ = a1; // @error static type of multiplicative-expr with decimal operands is decimal<br><br>    var a3 = f / e;<br>    int _ = a3; // @error static type of multiplicative-expr with decimal operands is decimal<br><br>    var a5 = 1d % f;<br>    float _ = a5; // @error static type of multiplicative-expr with decimal operands is decimal<br><br>    var a7 = getDecimal((20d % 2d)) % e;<br>    int _ = a7; // @error static type of multiplicative-expr with decimal operands is decimal    <br>}<br><br>function getDecimal(decimal d) returns decimal {<br>    return d % 2d;<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test for optional int the static type of the result being the basic type of the operands via invalid assignment.<br>Labels: multiplicative-expr, int, optional-type, var, DecimalNumber, numeric-nil-lifting<br><br>function errorFunction(int a, int? b) {<br>    int _ = a * b; // @error static type of multiplicative-expr with at least one int? operand is int?<br>    int _ = getOptionalInt(1 / 2) * b; // @error static type of multiplicative-expr with at least one int? operand is int?<br>    int _ = b % getOptionalInt(1 % 2); // @error static type of multiplicative-expr with at least one int? operand is int?<br>    int _ = b * getInt(1); // @error static type of multiplicative-expr with at least one int? operand is int?<br>}<br><br>function getInt(int i) returns int {<br>    return i * 1;<br>}<br><br>function getOptionalInt(int? i) returns int? {<br>    return i * 1;<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test for optional float the static type of the result being the basic type of the operands via invalid assignment.<br>Labels: multiplicative-expr, float, optional-type, var, DecimalFloatingPointNumber, numeric-nil-lifting<br><br>function errorFunction(float c, float? d) {<br>    float _ = d * c; // @error static type of multiplicative-expr with at least one float? operand is float?<br>    float _ = getFloat(2.0) * d; // @error static type of multiplicative-expr with at least one float? operand is float?<br>    float _ = d % getOptionalFloat(1.0 % 2f); // @error static type of multiplicative-expr with at least one float? operand is float?<br>    float _ = c / getOptionalFloat(1); // @error static type of multiplicative-expr with at least one float? operand is float?<br>}<br><br>function getFloat(float f) returns float {<br>    return f / 1f;<br>}<br><br>function getOptionalFloat(float? f) returns float? {<br>    return f / 1f;<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test for optional decimal the static type of the result being the basic type of the operands via invalid assignment.<br>Labels: multiplicative-expr, int, float, decimal, optional-type, var, DecimalFloatingPointNumber, numeric-nil-lifting<br><br>function errorFunction(decimal e, decimal? f) {<br>    decimal _ = e * f; // @error static type of multiplicative-expr with at least one int? operand is int?<br>    decimal _ = getOptionalDecimal(1d / 2.0d) * e; // @error static type of multiplicative-expr with at least one int? operand is int?<br>    decimal _ = f % getOptionalDecimal(()); // @error static type of multiplicative-expr with at least one int? operand is int?<br>    decimal _ = getOptionalDecimal(3) * getDecimal(1); // @error static type of multiplicative-expr with at least one int? operand is int?<br>}<br><br>function getDecimal(decimal d) returns decimal {<br>    return d % 2d;<br>}<br><br>function getOptionalDecimal(decimal? d) returns decimal? {<br>    return d % 2d;<br>}<br></pre>
<h3>remainder.balt</h3>
<pre>Test-Case: output<br>Description: Test integer remainder non-panic scenarios, where one operand is negative<br>             and the other is positive.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -1234;<br>    int c = -1;<br>    int d = 1;<br>    int e = 60708;<br>    int f = 9223372036854775807;<br><br>    io:println(a % d); // @output 0<br>    io:println(a % e); // @output -7028<br>    io:println(a % f); // @output -1<br><br>    io:println(b % d); // @output 0<br>    io:println(b % e); // @output -1234<br>    io:println(b % f); // @output -1234<br><br>    io:println(c % d); // @output 0<br>    io:println(c % e); // @output -1<br>    io:println(c % f); // @output -1<br><br>    io:println(d % a); // @output 1<br>    io:println(d % b); // @output 1<br>    io:println(d % c); // @output 0<br><br>    io:println(e % a); // @output 60708<br>    io:println(e % b); // @output 242<br>    io:println(e % c); // @output 0<br><br>    io:println(f % a); // @output 9223372036854775807<br>    io:println(f % b); // @output 441<br>    io:println(f % c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-panic scenarios, where the first operand is zero.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -1234;<br>    int c = -1;<br>    int d = -0;<br>    int e = 0;<br>    int f = 1;<br>    int g = 60708;<br>    int h = 9223372036854775807;<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 0<br>    io:println(d % f); // @output 0<br>    io:println(d % g); // @output 0<br>    io:println(d % h); // @output 0<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 0<br>    io:println(e % c); // @output 0<br>    io:println(e % f); // @output 0<br>    io:println(e % g); // @output 0<br>    io:println(e % h); // @output 0<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 1 for integer remainder panic on remainder by zero.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -0;<br><br>    int _ = a % b; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 2 for integer remainder panic on remainder by zero.<br>Labels: multiplicative-expr, int, DecimalNumber, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = 0;<br><br>    int _ = a % b; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 8 for integer remainder panic on remainder by zero.<br>Labels: multiplicative-expr, int, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int _ = int:MIN_VALUE % -0; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test 1 for output on integer remainder when division overflows.<br>Labels: multiplicative-expr, int, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -1;<br>    int c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test 2 for output on integer remainder  when division overflows.<br>Labels: multiplicative-expr, int, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    io:println(int:MIN_VALUE % -1); // @output 0<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer remainder panic on remainder by zero, for int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, DecimalNumber, int:MIN_VALUE<br><br>function init() {<br>    int:Signed8 a = -0;<br>    int _ = int:MIN_VALUE % a; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test output on int:Signed8 remainder when division overflows.<br>Labels: multiplicative-expr, int:Signed8, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int:Signed8 b = -1;<br>    int c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer remainder panic on remainder by zero, for int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int:Signed16 a = -0;<br>    int _ = int:MIN_VALUE % a; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test output on int:Signed16 remainder when division overflows.<br>Labels: multiplicative-expr, int:Signed16, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int:Signed16 b = -1;<br>    int c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer remainder panic on remainder by zero, for int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int:Signed32 a = -0;<br>    int _ = int:MIN_VALUE % a; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test output on int:Signed32 remainder when division overflows.<br>Labels: multiplicative-expr, int:Signed32, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int:Signed32 b = -1;<br>    int c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test output on user-defined subtype of int remainder when division overflows.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, unary-minus, module-type-defn, int:MIN_VALUE<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    Ints b = -1;<br>    int c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for optional positive non-zero integers.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    int? a = 1;<br>    int? b = 2;<br>    int? c = 4611686018427387903;<br>    int? d = 6917529027641081853;<br>    int? e = 9223372036854775807;<br>    int? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output 1<br>    io:println(a % c); // @output 1<br>    io:println(a % d); // @output 1<br>    io:println(a % e); // @output 1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output 2<br>    io:println(b % d); // @output 2<br>    io:println(b % e); // @output 2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 1<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output 4611686018427387903<br>    io:println(c % e); // @output 4611686018427387903<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 1<br>    io:println(d % c); // @output 2305843009213693950<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output 6917529027641081853<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 1<br>    io:println(e % c); // @output 1<br>    io:println(e % d); // @output 2305843009213693954<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for optional negative non-zero integers.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus<br><br>function init() {<br>    int? a = -1;<br>    int? b = -2;<br>    int? c = -4611686018427387903;<br>    int? d = -6917529027641081853;<br>    int? e = -9223372036854775807;<br>    int? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output -1<br>    io:println(a % c); // @output -1<br>    io:println(a % d); // @output -1<br>    io:println(a % e); // @output -1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output -2<br>    io:println(b % d); // @output -2<br>    io:println(b % e); // @output -2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output -1<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output -4611686018427387903<br>    io:println(c % e); // @output -4611686018427387903<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output -1<br>    io:println(d % c); // @output -2305843009213693950<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output -6917529027641081853<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output -1<br>    io:println(e % c); // @output -1<br>    io:println(e % d); // @output -2305843009213693954<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where one operand is negative<br>             and the other is positive, with optional type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -1234;<br>    int? c = -1;<br>    int? d = 1;<br>    int? e = 60708;<br>    int? f = 9223372036854775807;<br>    int? g = ();<br><br>    io:println(a % d); // @output 0<br>    io:println(a % e); // @output -7028<br>    io:println(a % f); // @output -1<br>    io:println((a % g).toBalString()); // @output ()<br><br>    io:println(b % d); // @output 0<br>    io:println(b % e); // @output -1234<br>    io:println(b % f); // @output -1234<br>    io:println((b % g).toBalString()); // @output ()<br><br>    io:println(c % d); // @output 0<br>    io:println(c % e); // @output -1<br>    io:println(c % f); // @output -1<br>    io:println((c % g).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 1<br>    io:println(d % b); // @output 1<br>    io:println(d % c); // @output 0<br>    io:println((d % g).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 60708<br>    io:println(e % b); // @output 242<br>    io:println(e % c); // @output 0<br>    io:println((e % g).toBalString()); // @output ()<br><br>    io:println(f % a); // @output 9223372036854775807<br>    io:println(f % b); // @output 441<br>    io:println(f % c); // @output 0<br>    io:println((f % g).toBalString()); // @output ()<br><br>    io:println((g % a).toBalString()); // @output ()<br>    io:println((g % b).toBalString()); // @output ()<br>    io:println((g % c).toBalString()); // @output ()<br>    io:println((g % d).toBalString()); // @output ()<br>    io:println((g % e).toBalString()); // @output ()<br>    io:println((g % f).toBalString()); // @output ()<br>    io:println((g % g).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where at least one operand is zero,<br>             with optional type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -1234;<br>    int? c = -1;<br>    int? d = -0;<br>    int? e = 0;<br>    int? f = 1;<br>    int? g = 60708;<br>    int? h = 9223372036854775807;<br>    int? i = ();<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 0<br>    io:println(d % f); // @output 0<br>    io:println(d % g); // @output 0<br>    io:println(d % h); // @output 0<br>    io:println((d % i).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 0<br>    io:println(e % c); // @output 0<br>    io:println(e % f); // @output 0<br>    io:println(e % g); // @output 0<br>    io:println(e % h); // @output 0<br>    io:println((e % i).toBalString()); // @output ()<br><br>    io:println((i % d).toBalString()); // @output ()<br>    io:println((i % e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 1 for integer remainder panic on remainder by zero,<br>             with optional int type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -0;<br><br>    int? _ = a % b; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 2 for integer remainder panic on remainder by zero,<br>             with optional int type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = 0;<br><br>    int? _ = a % b; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test for output on integer remainder overflow, with optional int type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -1;<br>    int? c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for positive non-zero integers,<br>             for optional int:Unsigned8.<br>Labels: multiplicative-expr, int:Unsigned8, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    int:Unsigned8? a = 1;<br>    int:Unsigned8? b = 2;<br>    int:Unsigned8? c = 3;<br>    int:Unsigned8? d = 86;<br>    int:Unsigned8? e = 255;<br>    int:Unsigned8? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output 1<br>    io:println(a % c); // @output 1<br>    io:println(a % d); // @output 1<br>    io:println(a % e); // @output 1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output 2<br>    io:println(b % d); // @output 2<br>    io:println(b % e); // @output 2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 1<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output 3<br>    io:println(c % e); // @output 3<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 2<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output 86<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 1<br>    io:println(e % c); // @output 0<br>    io:println(e % d); // @output 83<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where at least one operand is zero,<br>             for optional int:Unsigned8.<br>Labels: multiplicative-expr, int:Unsigned8, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    int:Unsigned8? a = 0;<br>    int:Unsigned8? b = 1;<br>    int:Unsigned8? c = 128;<br>    int:Unsigned8? d = 255;<br>    int:Unsigned8? e = ();<br><br>    io:println(a % b); // @output 0<br>    io:println(a % c); // @output 0<br>    io:println(a % d); // @output 0<br>    io:println((a % e).toBalString()); // @output ()<br><br>    io:println((e % a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for positive non-zero integers, for optional byte.<br>Labels: multiplicative-expr, byte, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    byte? a = 1;<br>    byte? b = 2;<br>    byte? c = 3;<br>    byte? d = 86;<br>    byte? e = 255;<br>    byte? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output 1<br>    io:println(a % c); // @output 1<br>    io:println(a % d); // @output 1<br>    io:println(a % e); // @output 1<br>    io:println((a % f).toBalString()); // @output ()<br><br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output 2<br>    io:println(b % d); // @output 2<br>    io:println(b % e); // @output 2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 1<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output 3<br>    io:println(c % e); // @output 3<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 2<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output 86<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 1<br>    io:println(e % c); // @output 0<br>    io:println(e % d); // @output 83<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where at least one operand is zero, for optional byte.<br>Labels: multiplicative-expr, byte, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    byte? a = 0;<br>    byte? b = 1;<br>    byte? c = 128;<br>    byte? d = 255;<br>    byte? e = ();<br><br>    io:println(a % b); // @output 0<br>    io:println(a % c); // @output 0<br>    io:println(a % d); // @output 0<br>    io:println((a % e).toBalString()); // @output ()<br><br>    io:println((e % a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for positive non-zero integers, for optional int:Unsigned16.<br>Labels: multiplicative-expr, int:Unsigned16, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    int:Unsigned16? a = 1;<br>    int:Unsigned16? b = 2;<br>    int:Unsigned16? c = 5;<br>    int:Unsigned16? d = 40123;<br>    int:Unsigned16? e = 65535;<br>    int:Unsigned16? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output 1<br>    io:println(a % c); // @output 1<br>    io:println(a % d); // @output 1<br>    io:println(a % e); // @output 1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output 2<br>    io:println(b % d); // @output 2<br>    io:println(b % e); // @output 2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 1<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output 5<br>    io:println(c % e); // @output 5<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 1<br>    io:println(d % c); // @output 3<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output 40123<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 1<br>    io:println(e % c); // @output 0<br>    io:println(e % d); // @output 25412<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where at least one operand is zero, for optional int:Unsigned16.<br>Labels: multiplicative-expr, int:Unsigned16, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    int:Unsigned16? a = 0;<br>    int:Unsigned16? b = 1;<br>    int:Unsigned16? c = 128;<br>    int:Unsigned16? d = 255;<br>    int:Unsigned16? e = ();<br><br>    io:println(a % b); // @output 0<br>    io:println(a % c); // @output 0<br>    io:println(a % d); // @output 0<br>    io:println((a % e).toBalString()); // @output ()<br><br>    io:println((e % a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for positive non-zero integers, for optional int:Unsigned32.<br>Labels: multiplicative-expr, int:Unsigned32, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    int:Unsigned32? a = 1;<br>    int:Unsigned32? b = 2;<br>    int:Unsigned32? c = 10;<br>    int:Unsigned32? d = 12034;<br>    int:Unsigned32? e = 429496729;<br>    int:Unsigned32? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output 1<br>    io:println(a % c); // @output 1<br>    io:println(a % d); // @output 1<br>    io:println(a % e); // @output 1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output 2<br>    io:println(b % d); // @output 2<br>    io:println(b % e); // @output 2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 0<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output 10<br>    io:println(c % e); // @output 10<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 4<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output 12034<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 1<br>    io:println(e % c); // @output 9<br>    io:println(e % d); // @output 3269<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where at least one operand is zero, for optional int:Unsigned32.<br>Labels: multiplicative-expr, int:Unsigned32, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    int:Unsigned32? a = 0;<br>    int:Unsigned32? b = 1;<br>    int:Unsigned32? c = 1259273;<br>    int:Unsigned32? d = 4294967295;<br>    int:Unsigned32? e = ();<br><br>    io:println(a % b); // @output 0<br>    io:println(a % c); // @output 0<br>    io:println(a % d); // @output 0<br>    io:println((a % e).toBalString()); // @output ()<br><br>    io:println((e % a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for positive non-zero integers, for optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    int:Signed8? a = 1;<br>    int:Signed8? b = 2;<br>    int:Signed8? c = 10;<br>    int:Signed8? d = 100;<br>    int:Signed8? e = 127;<br>    int:Signed8? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output 1<br>    io:println(a % c); // @output 1<br>    io:println(a % d); // @output 1<br>    io:println(a % e); // @output 1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output 2<br>    io:println(b % d); // @output 2<br>    io:println(b % e); // @output 2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 0<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output 10<br>    io:println(c % e); // @output 10<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 0<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output 100<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 1<br>    io:println(e % c); // @output 7<br>    io:println(e % d); // @output 27<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for negative non-zero integers, for optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus<br><br>function init() {<br>    int:Signed8? a = -1;<br>    int:Signed8? b = -2;<br>    int:Signed8? c = -100;<br>    int:Signed8? d = -121;<br>    int:Signed8? e = -128;<br>    int:Signed8? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output -1<br>    io:println(a % c); // @output -1<br>    io:println(a % d); // @output -1<br>    io:println(a % e); // @output -1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output -2<br>    io:println(b % d); // @output -2<br>    io:println(b % e); // @output -2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 0<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output -100<br>    io:println(c % e); // @output -100<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output -1<br>    io:println(d % c); // @output -21<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output -121<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 0<br>    io:println(e % c); // @output -28<br>    io:println(e % d); // @output -7<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where at least one operand is zero, for optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus<br><br>function init() {<br>    int:Signed8? a = -128;<br>    int:Signed8? b = -100;<br>    int:Signed8? c = -1;<br>    int:Signed8? d = -0;<br>    int:Signed8? e = 0;<br>    int:Signed8? f = 1;<br>    int:Signed8? g = 100;<br>    int:Signed8? h = 127;<br>    int:Signed8? i = ();<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 0<br>    io:println(d % f); // @output 0<br>    io:println(d % g); // @output 0<br>    io:println(d % h); // @output 0<br>    io:println((d % i).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 0<br>    io:println(e % c); // @output 0<br>    io:println(e % f); // @output 0<br>    io:println(e % g); // @output 0<br>    io:println(e % h); // @output 0<br>    io:println((e % i).toBalString()); // @output ()<br><br>    io:println((i % d).toBalString()); // @output ()<br>    io:println((i % e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer remainder panic on remainder by zero with optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int:Signed8? a = -0;<br>    int? _ = int:MIN_VALUE % a; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test output on optional int:Signed8 remainder when division overflows.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int:Signed8? b = -1;<br>    int? c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for positive non-zero integers, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, nil-literal, value:toBalString<br><br>function init() {<br>    int:Signed16? a = 1;<br>    int:Signed16? b = 2;<br>    int:Signed16? c = 10;<br>    int:Signed16? d = 12345;<br>    int:Signed16? e = 32767;<br>    int:Signed16? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output 1<br>    io:println(a % c); // @output 1<br>    io:println(a % d); // @output 1<br>    io:println(a % e); // @output 1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output 2<br>    io:println(b % d); // @output 2<br>    io:println(b % e); // @output 2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 0<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output 10<br>    io:println(c % e); // @output 10<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 1<br>    io:println(d % c); // @output 5<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output 12345<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 1<br>    io:println(e % c); // @output 7<br>    io:println(e % d); // @output 8077<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for negative non-zero integers, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus<br><br>function init() {<br>    int:Signed16? a = -1;<br>    int:Signed16? b = -2;<br>    int:Signed16? c = -100;<br>    int:Signed16? d = -20000;<br>    int:Signed16? e = -32768;<br>    int:Signed16? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output -1<br>    io:println(a % c); // @output -1<br>    io:println(a % d); // @output -1<br>    io:println(a % e); // @output -1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output -2<br>    io:println(b % d); // @output -2<br>    io:println(b % e); // @output -2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 0<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output -100<br>    io:println(c % e); // @output -100<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 0<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output -20000<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 0<br>    io:println(e % c); // @output -68<br>    io:println(e % d); // @output -12768<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where at least one operand is zero, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus<br><br>function init() {<br>    int:Signed16? a = -32768;<br>    int:Signed16? b = -100;<br>    int:Signed16? c = -1;<br>    int:Signed16? d = -0;<br>    int:Signed16? e = 0;<br>    int:Signed16? f = 1;<br>    int:Signed16? g = 1100;<br>    int:Signed16? h = 32767;<br>    int:Signed16? i = ();<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 0<br>    io:println(d % f); // @output 0<br>    io:println(d % g); // @output 0<br>    io:println(d % h); // @output 0<br>    io:println((d % i).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 0<br>    io:println(e % c); // @output 0<br>    io:println(e % f); // @output 0<br>    io:println(e % g); // @output 0<br>    io:println(e % h); // @output 0<br>    io:println((e % i).toBalString()); // @output ()<br><br>    io:println((i % d).toBalString()); // @output ()<br>    io:println((i % e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer remainder panic on remainder by zero.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int:Signed16? a = -0;<br>    int? _ = int:MIN_VALUE % a; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test output on optional int:Signed16 remainder when division overflows.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int:Signed16? b = -1;<br>    int? c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for positive non-zero integers, for optional int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus<br><br>function init() {<br>    int:Signed32? a = 1;<br>    int:Signed32? b = 2;<br>    int:Signed32? c = 10;<br>    int:Signed32? d = 1000;<br>    int:Signed32? e = 2147483647;<br>    int:Signed32? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output 1<br>    io:println(a % c); // @output 1<br>    io:println(a % d); // @output 1<br>    io:println(a % e); // @output 1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output 2<br>    io:println(b % d); // @output 2<br>    io:println(b % e); // @output 2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 0<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output 10<br>    io:println(c % e); // @output 10<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 0<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output 1000<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 1<br>    io:println(e % c); // @output 7<br>    io:println(e % d); // @output 647<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for negative non-zero integers, for optional int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus<br><br>function init() {<br>    int:Signed32? a = -1;<br>    int:Signed32? b = -2;<br>    int:Signed32? c = -100;<br>    int:Signed32? d = -20000;<br>    int:Signed32? e = -2147483648;<br>    int:Signed32? f = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output -1<br>    io:println(a % c); // @output -1<br>    io:println(a % d); // @output -1<br>    io:println(a % e); // @output -1<br>    io:println((a % f).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println(b % c); // @output -2<br>    io:println(b % d); // @output -2<br>    io:println(b % e); // @output -2<br>    io:println((b % f).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 0<br>    io:println(c % c); // @output 0<br>    io:println(c % d); // @output -100<br>    io:println(c % e); // @output -100<br>    io:println((c % f).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 0<br>    io:println(d % d); // @output 0<br>    io:println(d % e); // @output -20000<br>    io:println((d % f).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 0<br>    io:println(e % c); // @output -48<br>    io:println(e % d); // @output -3648<br>    io:println(e % e); // @output 0<br>    io:println((e % f).toBalString()); // @output ()<br><br>    io:println((f % a).toBalString()); // @output ()<br>    io:println((f % b).toBalString()); // @output ()<br>    io:println((f % c).toBalString()); // @output ()<br>    io:println((f % d).toBalString()); // @output ()<br>    io:println((f % e).toBalString()); // @output ()<br>    io:println((f % f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where at least one operand is zero, for optional int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus<br><br>function init() {<br>    int:Signed32? a = -2147483648;<br>    int:Signed32? b = -12342340;<br>    int:Signed32? c = -1;<br>    int:Signed32? d = -0;<br>    int:Signed32? e = 0;<br>    int:Signed32? f = 1;<br>    int:Signed32? g = 139456264;<br>    int:Signed32? h = 2147483647;<br>    int:Signed32? i = ();<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % c); // @output 0<br>    io:println(d % f); // @output 0<br>    io:println(d % g); // @output 0<br>    io:println(d % h); // @output 0<br>    io:println((d % i).toBalString()); // @output ()<br><br>    io:println(e % a); // @output 0<br>    io:println(e % b); // @output 0<br>    io:println(e % c); // @output 0<br>    io:println(e % f); // @output 0<br>    io:println(e % g); // @output 0<br>    io:println(e % h); // @output 0<br>    io:println((e % i).toBalString()); // @output ()<br><br>    io:println((i % d).toBalString()); // @output ()<br>    io:println((i % e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer remainder panic on remainder by zero.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int:Signed32? a = -0;<br>    int? _ = int:MIN_VALUE % a; // @panic remainder by zero<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test output on optional int:Signed32 remainder when division overflows.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int:Signed32? b = -1;<br>    int? c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for positive non-zero integers,<br>             for user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, nil-literal, unary-minus, module-type-defn, optional-type<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    Ints? a = 1;<br>    Ints? b = 2;<br>    Ints? c = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output 1<br>    io:println((a % c).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println((b % c).toBalString()); // @output ()<br><br>    io:println((c % a).toBalString()); // @output ()<br>    io:println((c % b).toBalString()); // @output ()<br>    io:println((c % c).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, for negative non-zero integers,<br>             for user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, nil-literal, unary-minus, module-type-defn, optional-type<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    Ints? a = -1;<br>    Ints? b = -2;<br>    Ints? c = ();<br><br>    io:println(a % a); // @output 0<br>    io:println(a % b); // @output -1<br>    io:println((a % c).toBalString()); // @output ()<br><br>    io:println(b % a); // @output 0<br>    io:println(b % b); // @output 0<br>    io:println((b % c).toBalString()); // @output ()<br><br>    io:println((c % a).toBalString()); // @output ()<br>    io:println((c % b).toBalString()); // @output ()<br>    io:println((c % c).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where one operand is negative<br>             and the other is positive, for user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, nil-literal, unary-minus, module-type-defn, optional-type<br><br>type Ints -2|-1|0|1|2?;<br><br>function init() {<br>    Ints a = -1;<br>    Ints b = -2;<br>    Ints c = 1;<br>    Ints d = 2;<br>    Ints e = ();<br><br>    io:println(a % c); // @output 0<br>    io:println(a % d); // @output -1<br>    io:println((a % e).toBalString()); // @output ()<br><br>    io:println(b % c); // @output 0<br>    io:println(b % d); // @output 0<br>    io:println((b % e).toBalString()); // @output ()<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 1<br>    io:println((c % e).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println((d % e).toBalString()); // @output ()<br><br>    io:println((e % a).toBalString()); // @output ()<br>    io:println((e % b).toBalString()); // @output ()<br>    io:println((e % c).toBalString()); // @output ()<br>    io:println((e % d).toBalString()); // @output ()<br>    io:println((e % e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-overflow scenarios, where one operand is zero, for<br>             user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, nil-literal, unary-minus, module-type-defn, optional-type<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    Ints? a = -2;<br>    Ints? b = -1;<br>    Ints? c = -0;<br>    Ints? d = 0;<br>    Ints? e = 1;<br>    Ints? f = 2;<br>    Ints? g = ();<br><br>    io:println(c % a); // @output 0<br>    io:println(c % b); // @output 0<br>    io:println(c % e); // @output 0<br>    io:println(c % f); // @output 0<br>    io:println((c % g).toBalString()); // @output ()<br><br>    io:println(d % a); // @output 0<br>    io:println(d % b); // @output 0<br>    io:println(d % e); // @output 0<br>    io:println(d % f); // @output 0<br>    io:println((d % g).toBalString()); // @output ()<br><br>    io:println((g % c).toBalString()); // @output ()<br>    io:println((g % d).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test 1 for output on user-defined optional subtype of int remainder when division overflows.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, unary-minus, module-type-defn, optional-type, int:MIN_VALUE<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    Ints? b = -1;<br>    int? c = a % b;<br>    io:println(c); // @output 0<br>}<br><br></pre>
<pre>Test-Case: output<br>Description: Test 2 for output on user-defined optional subtype of int remainder when division overflows.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, unary-minus, module-type-defn, optional-type, int:MIN_VALUE<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    Ints? b = -1;<br>    int? c = a % b;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test function and method call as integer remainder operands.<br>Labels: multiplicative-expr, int, DecimalNumber, function-call-expr, module-class-defn, implicit-new-expr, method-call-expr<br><br>function init() {<br>    Class f = new;<br>    int g = f.getInt() % getInt();<br>    io:println(g); // @output 1<br>}<br><br>function getInt() returns int {<br>    return 10 % 4;<br>}<br><br>class Class {<br>    function getInt() returns int {<br>        return 63;<br>    }<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test let expression in integer remainder operands.<br>Labels: multiplicative-expr, int, DecimalNumber, let-expr<br><br>function init() {<br>    int h = (let int h1 = 40 % 4 in h1) % 5;<br>    io:println(h); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary expressions in integer remainder operands.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-plus, unary-minus, unary-complement<br><br>function init() {<br>    int k = +43 % -3;<br>    io:println(k); // @output 1<br><br>    int l = -(-20 % 6);<br>    io:println(l); // @output 2<br><br>    int m = ~(20 % 3);<br>    io:println(m); // @output -3<br><br>    int n = ~21 % 3;<br>    io:println(n); // @output -1<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test conditional expressions as integer remainder operands.<br>Labels: multiplicative-expr, int, DecimalNumber, ternary-conditional-expr, binary-conditional-expr, nil-literal, union-type, error, optional-type<br><br>function init() {<br>    int|error a = 12;<br>    int? b = ();<br>    int c = (a is error ? 2 : a) % (b ?: 5);<br>    io:println(c); // @output 2<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test checking expressions as integer remainder operands.<br>Labels: multiplicative-expr, int, DecimalNumber, check, checkpanic, union-type, error<br><br>function init() returns error? {<br>    int|error a = 12;<br>    int c = check a % checkpanic a;<br>    io:println(c); // @output 0<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder with operands of different int subtypes.<br>Labels: multiplicative-expr, int, DecimalNumber, byte, int:Signed8, int:Signed16,<br>        int:Signed32, int:Unsigned8, int:Unsigned16, int:Unsigned32, module-type-defn, union-type, singleton-type<br><br>type Ints -9|9;<br><br>function init() returns error? {<br>    int a = -1;<br>    byte b = 2;<br>    int:Signed8 c = -3;<br>    int:Signed16 d = 4;<br>    int:Signed32 e = -5;<br>    int:Unsigned8 f = 6;<br>    int:Unsigned16 g = 7;<br>    int:Unsigned32 h = 8;<br>    Ints i = -9;<br><br>    int v = a % b;<br>    io:println(v); // @output -1<br><br>    v = a % c;<br>    io:println(v); // @output -1<br><br>    v = a % d;<br>    io:println(v); // @output -1<br><br>    v = a % e;<br>    io:println(v); // @output -1<br><br>    v = a % f;<br>    io:println(v); // @output -1<br><br>    v = a % g;<br>    io:println(v); // @output -1<br><br>    v = a % h;<br>    io:println(v); // @output -1<br><br>    v = a % i;<br>    io:println(v); // @output -1<br><br>    v = b % a;<br>    io:println(v); // @output 0<br><br>    v = b % c;<br>    io:println(v); // @output 2<br><br>    v = b % d;<br>    io:println(v); // @output 2<br><br>    v = b % e;<br>    io:println(v); // @output 2<br><br>    v = b % f;<br>    io:println(v); // @output 2<br><br>    v = b % g;<br>    io:println(v); // @output 2<br><br>    v = b % h;<br>    io:println(v); // @output 2<br><br>    v = b % i;<br>    io:println(v); // @output 2<br><br>    v = c % a;<br>    io:println(v); // @output 0<br><br>    v = c % b;<br>    io:println(v); // @output -1<br><br>    v = c % d;<br>    io:println(v); // @output -3<br><br>    v = c % e;<br>    io:println(v); // @output -3<br><br>    v = c % f;<br>    io:println(v); // @output -3<br><br>    v = c % g;<br>    io:println(v); // @output -3<br><br>    v = c % h;<br>    io:println(v); // @output -3<br><br>    v = c % i;<br>    io:println(v); // @output -3<br><br>    v = d % a;<br>    io:println(v); // @output 0<br><br>    v = d % b;<br>    io:println(v); // @output 0<br><br>    v = d % c;<br>    io:println(v); // @output 1<br><br>    v = d % e;<br>    io:println(v); // @output 4<br><br>    v = d % f;<br>    io:println(v); // @output 4<br><br>    v = d % g;<br>    io:println(v); // @output 4<br><br>    v = d % h;<br>    io:println(v); // @output 4<br><br>    v = d % i;<br>    io:println(v); // @output 4<br><br>    v = e % a;<br>    io:println(v); // @output 0<br><br>    v = e % b;<br>    io:println(v); // @output -1<br><br>    v = e % c;<br>    io:println(v); // @output -2<br><br>    v = e % d;<br>    io:println(v); // @output -1<br><br>    v = e % f;<br>    io:println(v); // @output -5<br><br>    v = e % g;<br>    io:println(v); // @output -5<br><br>    v = e % h;<br>    io:println(v); // @output -5<br><br>    v = e % i;<br>    io:println(v); // @output -5<br><br>    v = f % a;<br>    io:println(v); // @output 0<br><br>    v = f % b;<br>    io:println(v); // @output 0<br><br>    v = f % c;<br>    io:println(v); // @output 0<br><br>    v = f % d;<br>    io:println(v); // @output 2<br><br>    v = f % e;<br>    io:println(v); // @output 1<br><br>    v = f % g;<br>    io:println(v); // @output 6<br><br>    v = f % h;<br>    io:println(v); // @output 6<br><br>    v = f % i;<br>    io:println(v); // @output 6<br><br>    v = g % a;<br>    io:println(v); // @output 0<br><br>    v = g % b;<br>    io:println(v); // @output 1<br><br>    v = g % c;<br>    io:println(v); // @output 1<br><br>    v = g % d;<br>    io:println(v); // @output 3<br><br>    v = g % e;<br>    io:println(v); // @output 2<br><br>    v = g % f;<br>    io:println(v); // @output 1<br><br>    v = g % h;<br>    io:println(v); // @output 7<br><br>    v = g % i;<br>    io:println(v); // @output 7<br><br>    v = h % a;<br>    io:println(v); // @output 0<br><br>    v = h % b;<br>    io:println(v); // @output 0<br><br>    v = h % c;<br>    io:println(v); // @output 2<br><br>    v = h % d;<br>    io:println(v); // @output 0<br><br>    v = h % e;<br>    io:println(v); // @output 3<br><br>    v = h % f;<br>    io:println(v); // @output 2<br><br>    v = h % g;<br>    io:println(v); // @output 1<br><br>    v = h % i;<br>    io:println(v); // @output 8<br><br>    v = i % a;<br>    io:println(v); // @output 0<br><br>    v = i % b;<br>    io:println(v); // @output -1<br><br>    v = i % c;<br>    io:println(v); // @output 0<br><br>    v = i % d;<br>    io:println(v); // @output -1<br><br>    v = i % e;<br>    io:println(v); // @output -4<br><br>    v = i % f;<br>    io:println(v); // @output -3<br><br>    v = i % g;<br>    io:println(v); // @output -2<br><br>    v = i % h;<br>    io:println(v); // @output -1<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test 1 for integer remainder with operands of different optional int subtypes.<br>Labels: multiplicative-expr, int, DecimalNumber, byte, int:Signed8, int:Signed16,<br>        int:Signed32, int:Unsigned8, int:Unsigned16, int:Unsigned32, module-type-defn, nil-literal, union-type, singleton-type, optional-type, value:toBalString<br><br>type Ints -9|9;<br><br>function init() returns error? {<br>    int? a = -1;<br>    byte? b = 2;<br>    int:Signed8? c = -3;<br>    int:Signed16? d = 4;<br>    int:Signed32? e = -5;<br>    int:Unsigned8? f = 6;<br>    int:Unsigned16? g = 7;<br>    int:Unsigned32? h = 8;<br>    Ints? i = -9;<br>    int? j = ();<br><br>    int? v = a % b;<br>    io:println(v); // @output -1<br><br>    v = a % c;<br>    io:println(v); // @output -1<br><br>    v = a % d;<br>    io:println(v); // @output -1<br><br>    v = a % e;<br>    io:println(v); // @output -1<br><br>    v = a % f;<br>    io:println(v); // @output -1<br><br>    v = a % g;<br>    io:println(v); // @output -1<br><br>    v = a % h;<br>    io:println(v); // @output -1<br><br>    v = a % i;<br>    io:println(v); // @output -1<br><br>    v = a % j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = b % a;<br>    io:println(v); // @output 0<br><br>    v = b % c;<br>    io:println(v); // @output 2<br><br>    v = b % d;<br>    io:println(v); // @output 2<br><br>    v = b % e;<br>    io:println(v); // @output 2<br><br>    v = b % f;<br>    io:println(v); // @output 2<br><br>    v = b % g;<br>    io:println(v); // @output 2<br><br>    v = b % h;<br>    io:println(v); // @output 2<br><br>    v = b % i;<br>    io:println(v); // @output 2<br><br>    v = b % j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = c % a;<br>    io:println(v); // @output 0<br><br>    v = c % b;<br>    io:println(v); // @output -1<br><br>    v = c % d;<br>    io:println(v); // @output -3<br><br>    v = c % e;<br>    io:println(v); // @output -3<br><br>    v = c % f;<br>    io:println(v); // @output -3<br><br>    v = c % g;<br>    io:println(v); // @output -3<br><br>    v = c % h;<br>    io:println(v); // @output -3<br><br>    v = c % i;<br>    io:println(v); // @output -3<br><br>    v = c % j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = d % a;<br>    io:println(v); // @output 0<br><br>    v = d % b;<br>    io:println(v); // @output 0<br><br>    v = d % c;<br>    io:println(v); // @output 1<br><br>    v = d % e;<br>    io:println(v); // @output 4<br><br>    v = d % f;<br>    io:println(v); // @output 4<br><br>    v = d % g;<br>    io:println(v); // @output 4<br><br>    v = d % h;<br>    io:println(v); // @output 4<br><br>    v = d % i;<br>    io:println(v); // @output 4<br><br>    v = d % j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = e % a;<br>    io:println(v); // @output 0<br><br>    v = e % b;<br>    io:println(v); // @output -1<br><br>    v = e % c;<br>    io:println(v); // @output -2<br><br>    v = e % d;<br>    io:println(v); // @output -1<br><br>    v = e % f;<br>    io:println(v); // @output -5<br><br>    v = e % g;<br>    io:println(v); // @output -5<br><br>    v = e % h;<br>    io:println(v); // @output -5<br><br>    v = e % i;<br>    io:println(v); // @output -5<br><br>    v = e % j;<br>    io:println(v.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test 2 for integer remainder with operands of different optional int subtypes.<br>Labels: multiplicative-expr, int, DecimalNumber, byte, int:Signed8, int:Signed16,<br>        int:Signed32, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, module-type-defn, union-type, singleton-type, optional-type, value:toBalString<br><br>type Ints -9|9;<br><br>function init() returns error? {<br>    int? a = -1;<br>    byte? b = 2;<br>    int:Signed8? c = -3;<br>    int:Signed16? d = 4;<br>    int:Signed32? e = -5;<br>    int:Unsigned8? f = 6;<br>    int:Unsigned16? g = 7;<br>    int:Unsigned32? h = 8;<br>    Ints? i = -9;<br>    int? j = ();<br><br>    int? v = f % a;<br>    io:println(v); // @output 0<br><br>    v = f % b;<br>    io:println(v); // @output 0<br><br>    v = f % c;<br>    io:println(v); // @output 0<br><br>    v = f % d;<br>    io:println(v); // @output 2<br><br>    v = f % e;<br>    io:println(v); // @output 1<br><br>    v = f % g;<br>    io:println(v); // @output 6<br><br>    v = f % h;<br>    io:println(v); // @output 6<br><br>    v = f % i;<br>    io:println(v); // @output 6<br><br>    v = f % j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = g % a;<br>    io:println(v); // @output 0<br><br>    v = g % b;<br>    io:println(v); // @output 1<br><br>    v = g % c;<br>    io:println(v); // @output 1<br><br>    v = g % d;<br>    io:println(v); // @output 3<br><br>    v = g % e;<br>    io:println(v); // @output 2<br><br>    v = g % f;<br>    io:println(v); // @output 1<br><br>    v = g % h;<br>    io:println(v); // @output 7<br><br>    v = g % i;<br>    io:println(v); // @output 7<br><br>    v = g % j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = h % a;<br>    io:println(v); // @output 0<br><br>    v = h % b;<br>    io:println(v); // @output 0<br><br>    v = h % c;<br>    io:println(v); // @output 2<br><br>    v = h % d;<br>    io:println(v); // @output 0<br><br>    v = h % e;<br>    io:println(v); // @output 3<br><br>    v = h % f;<br>    io:println(v); // @output 2<br><br>    v = h % g;<br>    io:println(v); // @output 1<br><br>    v = h % i;<br>    io:println(v); // @output 8<br><br>    v = h % j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = i % a;<br>    io:println(v); // @output 0<br><br>    v = i % b;<br>    io:println(v); // @output -1<br><br>    v = i % c;<br>    io:println(v); // @output 0<br><br>    v = i % d;<br>    io:println(v); // @output -1<br><br>    v = i % e;<br>    io:println(v); // @output -4<br><br>    v = i % f;<br>    io:println(v); // @output -3<br><br>    v = i % g;<br>    io:println(v); // @output -2<br><br>    v = i % h;<br>    io:println(v); // @output -1<br><br>    v = i % j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j % a;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j % b;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j % c;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j % d;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j % e;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j % f;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j % g;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j % h;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j % i;<br>    io:println(v.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder with optional int operand's type written in different ways.<br>Labels: multiplicative-expr, int, DecimalNumber, nil-literal, optional-type, module-type-defn, union-type, singleton-type, value:toBalString<br><br>type T1 1|()|2;<br><br>type T2 1|2?;<br><br>function init() {<br>    T1 a = 1;<br>    T2 b = 2;<br>    ()|int c = ();<br><br>    int? v = a % a;<br>    io:println(v); // @output 0<br><br>    v = a % b;<br>    io:println(v); // @output 1<br><br>    v = a % c;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = b % b;<br>    io:println(v); // @output 0<br><br>    v = b % c;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = c % c;<br>    io:println(v.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer remainder non-panic scenarios at module-level.<br>Labels: multiplicative-expr, int, DecimalNumber<br><br>int a = 10;<br>int b = 2;<br>int c = a % b;<br>int d = a % 3;<br>int e = 21 % 3;<br><br>function init() {<br>    io:println(c); // @output 0<br>    io:println(d); // @output 1<br>    io:println(e); // @output 0<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test integer remainder panic at module-level.<br>Labels: multiplicative-expr, int:MIN_VALUE, DecimalNumber, unary-minus<br><br>int a = 5 % 0; // @panic remainder by zero</pre>
<h3>division.balt</h3>
<pre>Test-Case: output<br>Description: Test integer division non-panic scenarios, where one operand is negative <br>             and the other is positive.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -1234;<br>    int c = -1;<br>    int d = 1;<br>    int e = 60708;<br>    int f = 9223372036854775807;<br><br>    io:println(a / d); // @output -9223372036854775808<br>    io:println(a / e); // @output -151930092193035<br>    io:println(a / f); // @output -1<br><br>    io:println(b / d); // @output -1234<br>    io:println(b / e); // @output 0<br>    io:println(b / f); // @output 0<br><br>    io:println(c / d); // @output -1<br>    io:println(c / e); // @output 0<br>    io:println(c / f); // @output 0<br><br>    io:println(d / a); // @output 0<br>    io:println(d / b); // @output 0<br>    io:println(d / c); // @output -1<br><br>    io:println(e / a); // @output 0<br>    io:println(e / b); // @output -49<br>    io:println(e / c); // @output -60708<br><br>    io:println(f / a); // @output 0<br>    io:println(f / b); // @output -7474369559849899<br>    io:println(f / c); // @output -9223372036854775807<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-panic scenarios, where the first operand is zero.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -1234;<br>    int c = -1;<br>    int d = -0;<br>    int e = 0;<br>    int f = 1;<br>    int g = 60708;<br>    int h = 9223372036854775807;<br><br>    io:println(d / a); // @output 0<br>    io:println(d / b); // @output 0<br>    io:println(d / c); // @output 0<br>    io:println(d / f); // @output 0<br>    io:println(d / g); // @output 0<br>    io:println(d / h); // @output 0<br><br>    io:println(e / a); // @output 0<br>    io:println(e / b); // @output 0<br>    io:println(e / c); // @output 0<br>    io:println(e / f); // @output 0<br>    io:println(e / g); // @output 0<br>    io:println(e / h); // @output 0<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 1 for integer division panic on division by zero.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -0;<br><br>    int _ = a / b; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 2 for integer division panic on division by zero.<br>Labels: multiplicative-expr, int, DecimalNumber, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = 0;<br><br>    int _ = a / b; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 8 for integer division panic on division by zero.<br>Labels: multiplicative-expr, int, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int _ = int:MIN_VALUE / -0; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 1 for panic on integer division overflow.<br>Labels: multiplicative-expr, int, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -1;    <br>    int _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 2 for panic on integer division overflow.<br>Labels: multiplicative-expr, int, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int _ = int:MIN_VALUE / -1; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer division panic on division by zero.<br>Labels: multiplicative-expr, int:Signed8, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int:Signed8 a = -0;<br>    int _ = int:MIN_VALUE / a; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test panic on integer division overflow with int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int:Signed8 b = -1;<br>    int _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer division panic on division by zero.<br>Labels: multiplicative-expr, int:Signed16, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int:Signed16 a = -0;<br>    int _ = int:MIN_VALUE / a; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test panic on integer division overflow with int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int:Signed16 b = -1;<br>    int _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer division panic on division by zero.<br>Labels: multiplicative-expr, int:Signed32, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int:Signed32 a = -0;<br>    int _ = int:MIN_VALUE / a; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test panic on integer division overflow with int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, DecimalNumber, int:MIN_VALUE, unary-minus<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int:Signed32 b = -1;<br>    int _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test for integer division overflow with user-defined subtype of int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, unary-minus, module-type-defn,int:MIN_VALUE<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    Ints b = -1;<br>    int _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for optional positive non-zero integers.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int? a = 1;<br>    int? b = 2;<br>    int? c = 4611686018427387903;<br>    int? d = 6917529027641081853;<br>    int? e = 9223372036854775807;<br>    int? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 4611686018427387903<br>    io:println(c / b); // @output 2305843009213693951<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 6917529027641081853<br>    io:println(d / b); // @output 3458764513820540926<br>    io:println(d / c); // @output 1<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 9223372036854775807<br>    io:println(e / b); // @output 4611686018427387903<br>    io:println(e / c); // @output 2<br>    io:println(e / d); // @output 1<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for optional negative non-zero integers.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int? a = -1;<br>    int? b = -2;<br>    int? c = -4611686018427387903;<br>    int? d = -6917529027641081853;<br>    int? e = -9223372036854775807;<br>    int? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 4611686018427387903<br>    io:println(c / b); // @output 2305843009213693951<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 6917529027641081853<br>    io:println(d / b); // @output 3458764513820540926<br>    io:println(d / c); // @output 1<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 9223372036854775807<br>    io:println(e / b); // @output 4611686018427387903<br>    io:println(e / c); // @output 2<br>    io:println(e / d); // @output 1<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where one operand is negative <br>             and the other is positive, with optional type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -1234;<br>    int? c = -1;<br>    int? d = 1;<br>    int? e = 60708;<br>    int? f = 9223372036854775807;<br>    int? g = ();<br><br>    io:println(a / d); // @output -9223372036854775808<br>    io:println(a / e); // @output -151930092193035<br>    io:println(a / f); // @output -1<br>    io:println((a / g).toBalString()); // @output ()<br><br>    io:println(b / d); // @output -1234<br>    io:println(b / e); // @output 0<br>    io:println(b / f); // @output 0<br>    io:println((b / g).toBalString()); // @output ()<br><br>    io:println(c / d); // @output -1<br>    io:println(c / e); // @output 0<br>    io:println(c / f); // @output 0<br>    io:println((c / g).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 0<br>    io:println(d / b); // @output 0<br>    io:println(d / c); // @output -1<br>    io:println((d / g).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 0<br>    io:println(e / b); // @output -49<br>    io:println(e / c); // @output -60708<br>    io:println((e / g).toBalString()); // @output ()<br><br>    io:println(f / a); // @output 0<br>    io:println(f / b); // @output -7474369559849899<br>    io:println(f / c); // @output -9223372036854775807<br>    io:println((f / g).toBalString()); // @output ()<br><br>    io:println((g / a).toBalString()); // @output ()<br>    io:println((g / b).toBalString()); // @output ()<br>    io:println((g / c).toBalString()); // @output ()<br>    io:println((g / d).toBalString()); // @output ()<br>    io:println((g / e).toBalString()); // @output ()<br>    io:println((g / f).toBalString()); // @output ()<br>    io:println((g / g).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where at least one operand is zero,<br>             with optional type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -1234;<br>    int? c = -1;<br>    int? d = -0;<br>    int? e = 0;<br>    int? f = 1;<br>    int? g = 60708;<br>    int? h = 9223372036854775807;<br>    int? i = ();<br><br>    io:println(d / a); // @output 0<br>    io:println(d / b); // @output 0<br>    io:println(d / c); // @output 0<br>    io:println(d / f); // @output 0<br>    io:println(d / g); // @output 0<br>    io:println(d / h); // @output 0<br>    io:println((d / i).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 0<br>    io:println(e / b); // @output 0<br>    io:println(e / c); // @output 0<br>    io:println(e / f); // @output 0<br>    io:println(e / g); // @output 0<br>    io:println(e / h); // @output 0<br>    io:println((e / i).toBalString()); // @output ()<br><br>    io:println((i / d).toBalString()); // @output ()<br>    io:println((i / e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 1 for integer division panic on division by zero,<br>             with optional int type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, unary-minus, numeric-nil-lifting, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -0;<br><br>    int? _ = a / b; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 2 for integer division panic on division by zero,<br>             with optional int type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, numeric-nil-lifting, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = 0;<br><br>    int? _ = a / b; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test panic on integer division overflow, with optional int type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, int:MIN_VALUE, numeric-nil-lifting, unary-minus<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -1;    <br>    int? _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for positive non-zero integers,<br>             for optional int:Unsigned8.<br>Labels: multiplicative-expr, int:Unsigned8, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned8? a = 1;<br>    int:Unsigned8? b = 2;<br>    int:Unsigned8? c = 3;<br>    int:Unsigned8? d = 86;<br>    int:Unsigned8? e = 255;<br>    int:Unsigned8? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 3<br>    io:println(c / b); // @output 1<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 86<br>    io:println(d / b); // @output 43<br>    io:println(d / c); // @output 28<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 255<br>    io:println(e / b); // @output 127<br>    io:println(e / c); // @output 85<br>    io:println(e / d); // @output 2<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where at least one operand is zero,<br>             for optional int:Unsigned8.<br>Labels: multiplicative-expr, int:Unsigned8, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned8? a = 0;<br>    int:Unsigned8? b = 1;<br>    int:Unsigned8? c = 128;<br>    int:Unsigned8? d = 255;<br>    int:Unsigned8? e = ();<br><br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println((a / e).toBalString()); // @output ()<br><br>    io:println((e / a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for positive non-zero integers, for optional byte.<br>Labels: multiplicative-expr, byte, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    byte? a = 1;<br>    byte? b = 2;<br>    byte? c = 3;<br>    byte? d = 86;<br>    byte? e = 255;<br>    byte? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 3<br>    io:println(c / b); // @output 1<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 86<br>    io:println(d / b); // @output 43<br>    io:println(d / c); // @output 28<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 255<br>    io:println(e / b); // @output 127<br>    io:println(e / c); // @output 85<br>    io:println(e / d); // @output 2<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where at least one operand is zero, for optional byte.<br>Labels: multiplicative-expr, byte, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    byte? a = 0;<br>    byte? b = 1;<br>    byte? c = 128;<br>    byte? d = 255;<br>    byte? e = ();<br><br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println((a / e).toBalString()); // @output ()<br><br>    io:println((e / a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for positive non-zero integers, for optional int:Unsigned16.<br>Labels: multiplicative-expr, int:Unsigned16, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned16? a = 1;<br>    int:Unsigned16? b = 2;<br>    int:Unsigned16? c = 5;<br>    int:Unsigned16? d = 40123;<br>    int:Unsigned16? e = 65535;<br>    int:Unsigned16? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 5<br>    io:println(c / b); // @output 2<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 40123<br>    io:println(d / b); // @output 20061<br>    io:println(d / c); // @output 8024<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 65535<br>    io:println(e / b); // @output 32767<br>    io:println(e / c); // @output 13107<br>    io:println(e / d); // @output 1<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where at least one operand is zero, for optional int:Unsigned16.<br>Labels: multiplicative-expr, int:Unsigned16, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned16? a = 0;<br>    int:Unsigned16? b = 1;<br>    int:Unsigned16? c = 128;<br>    int:Unsigned16? d = 255;<br>    int:Unsigned16? e = ();<br><br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println((a / e).toBalString()); // @output ()<br><br>    io:println((e / a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for positive non-zero integers, for optional int:Unsigned32.<br>Labels: multiplicative-expr, int:Unsigned32, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned32? a = 1;<br>    int:Unsigned32? b = 2;<br>    int:Unsigned32? c = 10;<br>    int:Unsigned32? d = 12034;<br>    int:Unsigned32? e = 429496729;<br>    int:Unsigned32? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 10<br>    io:println(c / b); // @output 5<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 12034<br>    io:println(d / b); // @output 6017<br>    io:println(d / c); // @output 1203<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 429496729<br>    io:println(e / b); // @output 214748364<br>    io:println(e / c); // @output 42949672<br>    io:println(e / d); // @output 35690<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where at least one operand is zero, for optional int:Unsigned32.<br>Labels: multiplicative-expr, int:Unsigned32, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned32? a = 0;<br>    int:Unsigned32? b = 1;<br>    int:Unsigned32? c = 1259273;<br>    int:Unsigned32? d = 4294967295;<br>    int:Unsigned32? e = ();<br><br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println((a / e).toBalString()); // @output ()<br><br>    io:println((e / a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for positive non-zero integers, for optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Signed8? a = 1;<br>    int:Signed8? b = 2;<br>    int:Signed8? c = 10;<br>    int:Signed8? d = 100;<br>    int:Signed8? e = 127;<br>    int:Signed8? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 10<br>    io:println(c / b); // @output 5<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 100<br>    io:println(d / b); // @output 50<br>    io:println(d / c); // @output 10<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 127<br>    io:println(e / b); // @output 63<br>    io:println(e / c); // @output 12<br>    io:println(e / d); // @output 1<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for negative non-zero integers, for optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed8? a = -1;<br>    int:Signed8? b = -2;<br>    int:Signed8? c = -100;<br>    int:Signed8? d = -120;<br>    int:Signed8? e = -128;<br>    int:Signed8? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 100<br>    io:println(c / b); // @output 50<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 120<br>    io:println(d / b); // @output 60<br>    io:println(d / c); // @output 1<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 128<br>    io:println(e / b); // @output 64<br>    io:println(e / c); // @output 1<br>    io:println(e / d); // @output 1<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where at least one operand is zero, for optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed8? a = -128;<br>    int:Signed8? b = -100;<br>    int:Signed8? c = -1;<br>    int:Signed8? d = -0;<br>    int:Signed8? e = 0;<br>    int:Signed8? f = 1;<br>    int:Signed8? g = 100;<br>    int:Signed8? h = 127;<br>    int:Signed8? i = ();<br><br>    io:println(d / a); // @output 0<br>    io:println(d / b); // @output 0<br>    io:println(d / c); // @output 0<br>    io:println(d / f); // @output 0<br>    io:println(d / g); // @output 0<br>    io:println(d / h); // @output 0<br>    io:println((d / i).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 0<br>    io:println(e / b); // @output 0<br>    io:println(e / c); // @output 0<br>    io:println(e / f); // @output 0<br>    io:println(e / g); // @output 0<br>    io:println(e / h); // @output 0<br>    io:println((e / i).toBalString()); // @output ()<br><br>    io:println((i / d).toBalString()); // @output ()<br>    io:println((i / e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer division panic on division by zero with optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, int:MIN_VALUE, numeric-nil-lifting, unary-minus<br><br>function init() {<br>    int:Signed8? a = -0;<br>    int? _ = int:MIN_VALUE / a; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test panic on integer division overflow with optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, int:MIN_VALUE, numeric-nil-lifting, unary-minus<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int:Signed8? b = -1;<br>    int? _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for positive non-zero integers, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Signed16? a = 1;<br>    int:Signed16? b = 2;<br>    int:Signed16? c = 10;<br>    int:Signed16? d = 12345;<br>    int:Signed16? e = 32767;<br>    int:Signed16? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 10<br>    io:println(c / b); // @output 5<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 12345<br>    io:println(d / b); // @output 6172<br>    io:println(d / c); // @output 1234<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 32767<br>    io:println(e / b); // @output 16383<br>    io:println(e / c); // @output 3276<br>    io:println(e / d); // @output 2<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for negative non-zero integers, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed16? a = -1;<br>    int:Signed16? b = -2;<br>    int:Signed16? c = -100;<br>    int:Signed16? d = -20000;<br>    int:Signed16? e = -32768;<br>    int:Signed16? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 100<br>    io:println(c / b); // @output 50<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 20000<br>    io:println(d / b); // @output 10000<br>    io:println(d / c); // @output 200<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 32768<br>    io:println(e / b); // @output 16384<br>    io:println(e / c); // @output 327<br>    io:println(e / d); // @output 1<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where at least one operand is zero, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed16? a = -32768;<br>    int:Signed16? b = -100;<br>    int:Signed16? c = -1;<br>    int:Signed16? d = -0;<br>    int:Signed16? e = 0;<br>    int:Signed16? f = 1;<br>    int:Signed16? g = 1100;<br>    int:Signed16? h = 32767;<br>    int:Signed16? i = ();<br><br>    io:println(d / a); // @output 0<br>    io:println(d / b); // @output 0<br>    io:println(d / c); // @output 0<br>    io:println(d / f); // @output 0<br>    io:println(d / g); // @output 0<br>    io:println(d / h); // @output 0<br>    io:println((d / i).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 0<br>    io:println(e / b); // @output 0<br>    io:println(e / c); // @output 0<br>    io:println(e / f); // @output 0<br>    io:println(e / g); // @output 0<br>    io:println(e / h); // @output 0<br>    io:println((e / i).toBalString()); // @output ()<br><br>    io:println((i / d).toBalString()); // @output ()<br>    io:println((i / e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer division panic on division by zero.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, int:MIN_VALUE, numeric-nil-lifting, unary-minus<br><br>function init() {<br>    int:Signed16? a = -0;<br>    int? _ = int:MIN_VALUE / a; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test panic on integer division overflow with int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, int:MIN_VALUE, numeric-nil-lifting, unary-minus<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int:Signed16? b = -1;<br>    int? _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for positive non-zero integers, for optional int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed32? a = 1;<br>    int:Signed32? b = 2;<br>    int:Signed32? c = 10;<br>    int:Signed32? d = 1000;<br>    int:Signed32? e = 2147483647;<br>    int:Signed32? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 10<br>    io:println(c / b); // @output 5<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 1000<br>    io:println(d / b); // @output 500<br>    io:println(d / c); // @output 100<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 2147483647<br>    io:println(e / b); // @output 1073741823<br>    io:println(e / c); // @output 214748364<br>    io:println(e / d); // @output 2147483<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for negative non-zero integers, for optional int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed32? a = -1;<br>    int:Signed32? b = -2;<br>    int:Signed32? c = -100;<br>    int:Signed32? d = -20000;<br>    int:Signed32? e = -2147483648;<br>    int:Signed32? f = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println(a / c); // @output 0<br>    io:println(a / d); // @output 0<br>    io:println(a / e); // @output 0<br>    io:println((a / f).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println(b / c); // @output 0<br>    io:println(b / d); // @output 0<br>    io:println(b / e); // @output 0<br>    io:println((b / f).toBalString()); // @output ()<br><br>    io:println(c / a); // @output 100<br>    io:println(c / b); // @output 50<br>    io:println(c / c); // @output 1<br>    io:println(c / d); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println((c / f).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 20000<br>    io:println(d / b); // @output 10000<br>    io:println(d / c); // @output 200<br>    io:println(d / d); // @output 1<br>    io:println(d / e); // @output 0<br>    io:println((d / f).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 2147483648<br>    io:println(e / b); // @output 1073741824<br>    io:println(e / c); // @output 21474836<br>    io:println(e / d); // @output 107374<br>    io:println(e / e); // @output 1<br>    io:println((e / f).toBalString()); // @output ()<br><br>    io:println((f / a).toBalString()); // @output ()<br>    io:println((f / b).toBalString()); // @output ()<br>    io:println((f / c).toBalString()); // @output ()<br>    io:println((f / d).toBalString()); // @output ()<br>    io:println((f / e).toBalString()); // @output ()<br>    io:println((f / f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where at least one operand is zero, for optional int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed32? a = -2147483648;<br>    int:Signed32? b = -12342340;<br>    int:Signed32? c = -1;<br>    int:Signed32? d = -0;<br>    int:Signed32? e = 0;<br>    int:Signed32? f = 1;<br>    int:Signed32? g = 139456264;<br>    int:Signed32? h = 2147483647;<br>    int:Signed32? i = ();<br><br>    io:println(d / a); // @output 0<br>    io:println(d / b); // @output 0<br>    io:println(d / c); // @output 0<br>    io:println(d / f); // @output 0<br>    io:println(d / g); // @output 0<br>    io:println(d / h); // @output 0<br>    io:println((d / i).toBalString()); // @output ()<br><br>    io:println(e / a); // @output 0<br>    io:println(e / b); // @output 0<br>    io:println(e / c); // @output 0<br>    io:println(e / f); // @output 0<br>    io:println(e / g); // @output 0<br>    io:println(e / h); // @output 0<br>    io:println((e / i).toBalString()); // @output ()<br><br>    io:println((i / d).toBalString()); // @output ()<br>    io:println((i / e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 7 for integer division panic on division by zero.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, int:MIN_VALUE, numeric-nil-lifting, unary-minus<br><br>function init() {<br>    int:Signed32? a = -0;<br>    int? _ = int:MIN_VALUE / a; // @panic division by zero<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test panic on integer division overflow with int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, int:MIN_VALUE, numeric-nil-lifting, unary-minus<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int:Signed32? b = -1;<br>    int? _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for positive non-zero integers,<br>             for user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, nil-literal, unary-minus, module-type-defn, optional-type, numeric-nil-lifting<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    Ints? a = 1;<br>    Ints? b = 2;<br>    Ints? c = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println((a / c).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println((b / c).toBalString()); // @output ()<br><br>    io:println((c / a).toBalString()); // @output ()<br>    io:println((c / b).toBalString()); // @output ()<br>    io:println((c / c).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, for negative non-zero integers,<br>             for user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, nil-literal, unary-minus, module-type-defn, optional-type, numeric-nil-lifting<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    Ints? a = -1;<br>    Ints? b = -2;<br>    Ints? c = ();<br><br>    io:println(a / a); // @output 1<br>    io:println(a / b); // @output 0<br>    io:println((a / c).toBalString()); // @output ()<br><br>    io:println(b / a); // @output 2<br>    io:println(b / b); // @output 1<br>    io:println((b / c).toBalString()); // @output ()<br><br>    io:println((c / a).toBalString()); // @output ()<br>    io:println((c / b).toBalString()); // @output ()<br>    io:println((c / c).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where one operand is negative<br>             and the other is positive, for user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, unary-minus, nil-literal, module-type-defn, optional-type, numeric-nil-lifting<br><br>type Ints -2|-1|0|1|2?;<br><br>function init() {<br>    Ints a = -1;<br>    Ints b = -2;<br>    Ints c = 1;<br>    Ints d = 2;<br>    Ints e = ();<br><br>    io:println(a / c); // @output -1<br>    io:println(a / d); // @output 0<br>    io:println((a / e).toBalString()); // @output ()<br><br>    io:println(b / c); // @output -2<br>    io:println(b / d); // @output -1<br>    io:println((b / e).toBalString()); // @output ()<br><br>    io:println(c / a); // @output -1<br>    io:println(c / b); // @output 0<br>    io:println((c / e).toBalString()); // @output ()<br><br>    io:println(d / a); // @output -2<br>    io:println(d / b); // @output -1<br>    io:println((d / e).toBalString()); // @output ()<br><br>    io:println((e / a).toBalString()); // @output ()<br>    io:println((e / b).toBalString()); // @output ()<br>    io:println((e / c).toBalString()); // @output ()<br>    io:println((e / d).toBalString()); // @output ()<br>    io:println((e / e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-overflow scenarios, where one operand is zero, for<br>             user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, unary-minus, nil-literal, module-type-defn, optional-type, numeric-nil-lifting<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    Ints? a = -2;<br>    Ints? b = -1;<br>    Ints? c = -0;<br>    Ints? d = 0;<br>    Ints? e = 1;<br>    Ints? f = 2;<br>    Ints? g = ();<br><br>    io:println(c / a); // @output 0<br>    io:println(c / b); // @output 0<br>    io:println(c / e); // @output 0<br>    io:println(c / f); // @output 0<br>    io:println((c / g).toBalString()); // @output ()<br><br>    io:println(d / a); // @output 0<br>    io:println(d / b); // @output 0<br>    io:println(d / e); // @output 0<br>    io:println(d / f); // @output 0<br>    io:println((d / g).toBalString()); // @output ()<br><br>    io:println((g / c).toBalString()); // @output ()<br>    io:println((g / d).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 1 for integer division overflow with user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, unary-minus, module-type-defn, optional-type, int:MIN_VALUE, numeric-nil-lifting<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    Ints? b = -1;<br>    int? _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 2 for integer division overflow with user-defined subtype of optional int.<br>Labels: multiplicative-expr, union-type, singleton-type, DecimalNumber, unary-minus, module-type-defn, optional-type, int:MIN_VALUE, numeric-nil-lifting<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    Ints? b = -1;<br>    int? _ = a / b; // @panic integer overflow on division<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test function and method call as integer division operands.<br>Labels: multiplicative-expr, int, DecimalNumber, function-call-expr, module-class-defn, implicit-new-expr, method-call-expr<br><br>function init() {<br>    Class f = new;<br>    int g = f.getInt() / getInt();<br>    io:println(g); // @output 12<br>}<br><br>function getInt() returns int {<br>    return 10 / 2;<br>}<br><br>class Class {<br>    function getInt() returns int {<br>        return 60;<br>    }<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test let expression in integer division operands.<br>Labels: multiplicative-expr, int, DecimalNumber, let-expr<br><br>function init() {<br>    int h = (let int h1 = 40 / 4 in h1) / 5;<br>    io:println(h); // @output 2<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary expressions in integer division operands.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-plus, unary-minus, unary-complement<br><br>function init() {<br>    int k = +42 / -3;<br>    io:println(k); // @output -14<br><br>    int l = -(-20 / 5);<br>    io:println(l); // @output 4<br><br>    int m = ~(20 / 5);<br>    io:println(m); // @output -5<br><br>    int n = ~20 / 3;<br>    io:println(n); // @output -7<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test conditional expressions as integer division operands.<br>Labels: multiplicative-expr, int, DecimalNumber, ternary-conditional-expr, binary-conditional-expr, nil-literal, union-type, error, optional-type, numeric-nil-lifting<br><br>function init() {<br>    int|error a = 12;<br>    int? b = ();<br>    int c = (a is error ? 2 : a) / (b ?: 2);<br>    io:println(c); // @output 6<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test checking expressions as integer division operands.<br>Labels: multiplicative-expr, int, DecimalNumber, check, checkpanic, union-type, error<br><br>function init() returns error? {<br>    int|error a = 12;<br>    int c = check a / checkpanic a;<br>    io:println(c); // @output 1<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division with operands of different int subtypes.<br>Labels: multiplicative-expr, int, DecimalNumber, byte, int:Signed8, int:Signed16,<br>        int:Signed32, int:Unsigned8, int:Unsigned16, int:Unsigned32, module-type-defn, union-type, singleton-type<br><br>type Ints -9|9;<br><br>function init() returns error? {<br>    int a = -1;<br>    byte b = 2;<br>    int:Signed8 c = -3;<br>    int:Signed16 d = 4;<br>    int:Signed32 e = -5;<br>    int:Unsigned8 f = 6;<br>    int:Unsigned16 g = 7;<br>    int:Unsigned32 h = 8;<br>    Ints i = -9;<br><br>    int v = a / b;<br>    io:println(v); // @output 0<br><br>    v = a / c;<br>    io:println(v); // @output 0<br><br>    v = a / d;<br>    io:println(v); // @output 0<br><br>    v = a / e;<br>    io:println(v); // @output 0<br><br>    v = a / f;<br>    io:println(v); // @output 0<br><br>    v = a / g;<br>    io:println(v); // @output 0<br><br>    v = a / h;<br>    io:println(v); // @output 0<br><br>    v = a / i;<br>    io:println(v); // @output 0<br><br>    v = b / a;<br>    io:println(v); // @output -2<br><br>    v = b / c;<br>    io:println(v); // @output 0<br><br>    v = b / d;<br>    io:println(v); // @output 0<br><br>    v = b / e;<br>    io:println(v); // @output 0<br><br>    v = b / f;<br>    io:println(v); // @output 0<br><br>    v = b / g;<br>    io:println(v); // @output 0<br><br>    v = b / h;<br>    io:println(v); // @output 0<br><br>    v = b / i;<br>    io:println(v); // @output 0<br><br>    v = c / a;<br>    io:println(v); // @output 3<br><br>    v = c / b;<br>    io:println(v); // @output -1<br><br>    v = c / d;<br>    io:println(v); // @output 0<br><br>    v = c / e;<br>    io:println(v); // @output 0<br><br>    v = c / f;<br>    io:println(v); // @output 0<br><br>    v = c / g;<br>    io:println(v); // @output 0<br><br>    v = c / h;<br>    io:println(v); // @output 0<br><br>    v = c / i;<br>    io:println(v); // @output 0<br><br>    v = d / a;<br>    io:println(v); // @output -4<br><br>    v = d / b;<br>    io:println(v); // @output 2<br><br>    v = d / c;<br>    io:println(v); // @output -1<br><br>    v = d / e;<br>    io:println(v); // @output 0<br><br>    v = d / f;<br>    io:println(v); // @output 0<br><br>    v = d / g;<br>    io:println(v); // @output 0<br><br>    v = d / h;<br>    io:println(v); // @output 0<br><br>    v = d / i;<br>    io:println(v); // @output 0<br><br>    v = e / a;<br>    io:println(v); // @output 5<br><br>    v = e / b;<br>    io:println(v); // @output -2<br><br>    v = e / c;<br>    io:println(v); // @output 1<br><br>    v = e / d;<br>    io:println(v); // @output -1<br><br>    v = e / f;<br>    io:println(v); // @output 0<br><br>    v = e / g;<br>    io:println(v); // @output 0<br><br>    v = e / h;<br>    io:println(v); // @output 0<br><br>    v = e / i;<br>    io:println(v); // @output 0<br><br>    v = f / a;<br>    io:println(v); // @output -6<br><br>    v = f / b;<br>    io:println(v); // @output 3<br><br>    v = f / c;<br>    io:println(v); // @output -2<br><br>    v = f / d;<br>    io:println(v); // @output 1<br><br>    v = f / e;<br>    io:println(v); // @output -1<br><br>    v = f / g;<br>    io:println(v); // @output 0<br><br>    v = f / h;<br>    io:println(v); // @output 0<br><br>    v = f / i;<br>    io:println(v); // @output 0<br><br>    v = g / a;<br>    io:println(v); // @output -7<br><br>    v = g / b;<br>    io:println(v); // @output 3<br><br>    v = g / c;<br>    io:println(v); // @output -2<br><br>    v = g / d;<br>    io:println(v); // @output 1<br><br>    v = g / e;<br>    io:println(v); // @output -1<br><br>    v = g / f;<br>    io:println(v); // @output 1<br><br>    v = g / h;<br>    io:println(v); // @output 0<br><br>    v = g / i;<br>    io:println(v); // @output 0<br><br>    v = h / a;<br>    io:println(v); // @output -8<br><br>    v = h / b;<br>    io:println(v); // @output 4<br><br>    v = h / c;<br>    io:println(v); // @output -2<br><br>    v = h / d;<br>    io:println(v); // @output 2<br><br>    v = h / e;<br>    io:println(v); // @output -1<br><br>    v = h / f;<br>    io:println(v); // @output 1<br><br>    v = h / g;<br>    io:println(v); // @output 1<br><br>    v = h / i;<br>    io:println(v); // @output 0<br><br>    v = i / a;<br>    io:println(v); // @output 9<br><br>    v = i / b;<br>    io:println(v); // @output -4<br><br>    v = i / c;<br>    io:println(v); // @output 3<br><br>    v = i / d;<br>    io:println(v); // @output -2<br><br>    v = i / e;<br>    io:println(v); // @output 1<br><br>    v = i / f;<br>    io:println(v); // @output -1<br><br>    v = i / g;<br>    io:println(v); // @output -1<br><br>    v = i / h;<br>    io:println(v); // @output -1<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test 1 for integer division with operands of different optional int subtypes.<br>Labels: multiplicative-expr, int, DecimalNumber, byte, int:Signed8, int:Signed16, <br>        int:Signed32, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, module-type-defn, union-type, singleton-type, optional-type, value:toBalString, numeric-nil-lifting<br><br>type Ints -9|9;<br><br>function init() returns error? {<br>    int? a = -1;<br>    byte? b = 2;<br>    int:Signed8? c = -3;<br>    int:Signed16? d = 4;<br>    int:Signed32? e = -5;<br>    int:Unsigned8? f = 6;<br>    int:Unsigned16? g = 7;<br>    int:Unsigned32? h = 8;<br>    Ints? i = -9;<br>    int? j = ();<br><br>    int? v = a / b;<br>    io:println(v); // @output 0<br><br>    v = a / c;<br>    io:println(v); // @output 0<br><br>    v = a / d;<br>    io:println(v); // @output 0<br><br>    v = a / e;<br>    io:println(v); // @output 0<br><br>    v = a / f;<br>    io:println(v); // @output 0<br><br>    v = a / g;<br>    io:println(v); // @output 0<br><br>    v = a / h;<br>    io:println(v); // @output 0<br><br>    v = a / i;<br>    io:println(v); // @output 0<br><br>    v = a / j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = b / a;<br>    io:println(v); // @output -2<br><br>    v = b / c;<br>    io:println(v); // @output 0<br><br>    v = b / d;<br>    io:println(v); // @output 0<br><br>    v = b / e;<br>    io:println(v); // @output 0<br><br>    v = b / f;<br>    io:println(v); // @output 0<br><br>    v = b / g;<br>    io:println(v); // @output 0<br><br>    v = b / h;<br>    io:println(v); // @output 0<br><br>    v = b / i;<br>    io:println(v); // @output 0<br><br>    v = b / j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = c / a;<br>    io:println(v); // @output 3<br><br>    v = c / b;<br>    io:println(v); // @output -1<br><br>    v = c / d;<br>    io:println(v); // @output 0<br><br>    v = c / e;<br>    io:println(v); // @output 0<br><br>    v = c / f;<br>    io:println(v); // @output 0<br><br>    v = c / g;<br>    io:println(v); // @output 0<br><br>    v = c / h;<br>    io:println(v); // @output 0<br><br>    v = c / i;<br>    io:println(v); // @output 0<br><br>    v = c / j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = d / a;<br>    io:println(v); // @output -4<br><br>    v = d / b;<br>    io:println(v); // @output 2<br><br>    v = d / c;<br>    io:println(v); // @output -1<br><br>    v = d / e;<br>    io:println(v); // @output 0<br><br>    v = d / f;<br>    io:println(v); // @output 0<br><br>    v = d / g;<br>    io:println(v); // @output 0<br><br>    v = d / h;<br>    io:println(v); // @output 0<br><br>    v = d / i;<br>    io:println(v); // @output 0<br><br>    v = d / j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = e / a;<br>    io:println(v); // @output 5<br><br>    v = e / b;<br>    io:println(v); // @output -2<br><br>    v = e / c;<br>    io:println(v); // @output 1<br><br>    v = e / d;<br>    io:println(v); // @output -1<br><br>    v = e / f;<br>    io:println(v); // @output 0<br><br>    v = e / g;<br>    io:println(v); // @output 0<br><br>    v = e / h;<br>    io:println(v); // @output 0<br><br>    v = e / i;<br>    io:println(v); // @output 0<br><br>    v = e / j;<br>    io:println(v.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test 2 for integer division with operands of different optional int subtypes.<br>Labels: multiplicative-expr, int, DecimalNumber, byte, int:Signed8, int:Signed16, <br>        int:Signed32, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, module-type-defn, union-type, singleton-type, optional-type, value:toBalString, numeric-nil-lifting<br><br>type Ints -9|9;<br><br>function init() returns error? {<br>    int? a = -1;<br>    byte? b = 2;<br>    int:Signed8? c = -3;<br>    int:Signed16? d = 4;<br>    int:Signed32? e = -5;<br>    int:Unsigned8? f = 6;<br>    int:Unsigned16? g = 7;<br>    int:Unsigned32? h = 8;<br>    Ints? i = -9;<br>    int? j = ();<br><br>    int? v = f / a;<br>    io:println(v); // @output -6<br><br>    v = f / b;<br>    io:println(v); // @output 3<br><br>    v = f / c;<br>    io:println(v); // @output -2<br><br>    v = f / d;<br>    io:println(v); // @output 1<br><br>    v = f / e;<br>    io:println(v); // @output -1<br><br>    v = f / g;<br>    io:println(v); // @output 0<br><br>    v = f / h;<br>    io:println(v); // @output 0<br><br>    v = f / i;<br>    io:println(v); // @output 0<br><br>    v = f / j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = g / a;<br>    io:println(v); // @output -7<br><br>    v = g / b;<br>    io:println(v); // @output 3<br><br>    v = g / c;<br>    io:println(v); // @output -2<br><br>    v = g / d;<br>    io:println(v); // @output 1<br><br>    v = g / e;<br>    io:println(v); // @output -1<br><br>    v = g / f;<br>    io:println(v); // @output 1<br><br>    v = g / h;<br>    io:println(v); // @output 0<br><br>    v = g / i;<br>    io:println(v); // @output 0<br><br>    v = g / j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = h / a;<br>    io:println(v); // @output -8<br><br>    v = h / b;<br>    io:println(v); // @output 4<br><br>    v = h / c;<br>    io:println(v); // @output -2<br><br>    v = h / d;<br>    io:println(v); // @output 2<br><br>    v = h / e;<br>    io:println(v); // @output -1<br><br>    v = h / f;<br>    io:println(v); // @output 1<br><br>    v = h / g;<br>    io:println(v); // @output 1<br><br>    v = h / i;<br>    io:println(v); // @output 0<br><br>    v = h / j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = i / a;<br>    io:println(v); // @output 9<br><br>    v = i / b;<br>    io:println(v); // @output -4<br><br>    v = i / c;<br>    io:println(v); // @output 3<br><br>    v = i / d;<br>    io:println(v); // @output -2<br><br>    v = i / e;<br>    io:println(v); // @output 1<br><br>    v = i / f;<br>    io:println(v); // @output -1<br><br>    v = i / g;<br>    io:println(v); // @output -1<br><br>    v = i / h;<br>    io:println(v); // @output -1<br><br>    v = i / j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j / a;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j / b;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j / c;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j / d;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j / e;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j / f;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j / g;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j / h;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j / i;<br>    io:println(v.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division with optional int operand's type written in different ways.<br>Labels: multiplicative-expr, int, DecimalNumber, nil-literal, optional-type, module-type-defn, union-type, singleton-type, value:toBalString<br><br>type T1 1|()|2;<br><br>type T2 1|2?;<br><br>function init() {<br>    T1 a = 1;<br>    T2 b = 2;<br>    ()|int c = ();<br><br>    int? v = a / a;<br>    io:println(v); // @output 1<br><br>    v = a / b;<br>    io:println(v); // @output 0<br><br>    v = a / c;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = b / b;<br>    io:println(v); // @output 1<br><br>    v = b / c;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = c / c;<br>    io:println(v.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer division non-panic scenarios at module-level.<br>Labels: multiplicative-expr, int, DecimalNumber<br><br>int a = 10;<br>int b = 2;<br>int c = a / b;<br>int d = a / 3;<br>int e = 21 / 3;<br><br>function init() {<br>    io:println(c); // @output 5<br>    io:println(d); // @output 3<br>    io:println(e); // @output 7<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test integer division panic at module-level.<br>Labels: multiplicative-expr, int:MIN_VALUE, DecimalNumber, unary-minus<br><br>int a = int:MIN_VALUE / -1; // @panic integer overflow on division</pre>
<h3>multiplication.balt</h3>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where one operand is negative <br>             and the other is positive.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -1234;<br>    int c = -1;<br>    int d = 1;<br>    int e = 60708;<br>    int f = 9223372036854775807;<br><br>    io:println(a * d); // @output -9223372036854775808<br><br>    io:println(b * d); // @output -1234<br>    io:println(b * e); // @output -74913672<br><br>    io:println(c * d); // @output -1<br>    io:println(c * e); // @output -60708<br>    io:println(c * f); // @output -9223372036854775807<br><br>    io:println(d * a); // @output -9223372036854775808<br>    io:println(d * b); // @output -1234<br>    io:println(d * c); // @output -1<br><br>    io:println(e * b); // @output -74913672<br>    io:println(e * c); // @output -60708<br><br>    io:println(f * c); // @output -9223372036854775807<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int a = int:MIN_VALUE;<br>    int b = -1234;<br>    int c = -1;<br>    int d = -0;<br>    int e = 0;<br>    int f = 1;<br>    int g = 60708;<br>    int h = 9223372036854775807;<br><br>    io:println(a * d); // @output 0<br>    io:println(a * e); // @output 0<br><br>    io:println(b * d); // @output 0<br>    io:println(b * e); // @output 0<br><br>    io:println(c * d); // @output 0<br>    io:println(c * e); // @output 0<br><br>    io:println(d * a); // @output 0<br>    io:println(d * b); // @output 0<br>    io:println(d * c); // @output 0<br>    io:println(d * d); // @output 0<br>    io:println(d * e); // @output 0<br>    io:println(d * f); // @output 0<br>    io:println(d * g); // @output 0<br>    io:println(d * h); // @output 0<br><br>    io:println(e * a); // @output 0<br>    io:println(e * b); // @output 0<br>    io:println(e * c); // @output 0<br>    io:println(e * d); // @output 0<br>    io:println(e * e); // @output 0<br>    io:println(e * f); // @output 0<br>    io:println(e * g); // @output 0<br>    io:println(e * h); // @output 0<br><br>    io:println(f * d); // @output 0<br>    io:println(f * e); // @output 0<br><br>    io:println(g * d); // @output 0<br>    io:println(g * e); // @output 0<br><br>    io:println(h * d); // @output 0<br>    io:println(h * e); // @output 0<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 4 for integer multiplication overflow.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-minus, int:MIN_VALUE<br><br>function init() {<br>    int _ = -1 * int:MIN_VALUE; // @panic integer overflow on multiplication<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for optional positive non-zero integers.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int? a = 1;<br>    int? b = 2;<br>    int? c = 4611686018427387903;<br>    int? d = 6917529027641081853;<br>    int? e = 9223372036854775807;<br>    int? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 4611686018427387903<br>    io:println(a * d); // @output 6917529027641081853<br>    io:println(a * e); // @output 9223372036854775807<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 9223372036854775806<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 4611686018427387903<br>    io:println(c * b); // @output 9223372036854775806<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 6917529027641081853<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 9223372036854775807<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for optional negative non-zero integers.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int? a = -1;<br>    int? b = -2;<br>    int? c = -4611686018427387903;<br>    int? d = -6917529027641081853;<br>    int? e = -9223372036854775807;<br>    int? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 4611686018427387903<br>    io:println(a * d); // @output 6917529027641081853<br>    io:println(a * e); // @output 9223372036854775807<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 9223372036854775806<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 4611686018427387903<br>    io:println(c * b); // @output 9223372036854775806<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 6917529027641081853<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 9223372036854775807<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where one operand is negative <br>             and the other is positive, with optional type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -1234;<br>    int? c = -1;<br>    int? d = 1;<br>    int? e = 60708;<br>    int? f = 9223372036854775807;<br>    int? g = ();<br><br>    io:println(a * d); // @output -9223372036854775808<br>    io:println((a * g).toBalString()); // @output ()<br><br>    io:println(b * d); // @output -1234<br>    io:println(b * e); // @output -74913672<br>    io:println((b * g).toBalString()); // @output ()<br><br>    io:println(c * d); // @output -1<br>    io:println(c * e); // @output -60708<br>    io:println(c * f); // @output -9223372036854775807<br>    io:println((c * g).toBalString()); // @output ()<br><br>    io:println(d * a); // @output -9223372036854775808<br>    io:println(d * b); // @output -1234<br>    io:println(d * c); // @output -1<br>    io:println((d * g).toBalString()); // @output ()<br><br>    io:println(e * b); // @output -74913672<br>    io:println(e * c); // @output -60708<br>    io:println((e * g).toBalString()); // @output ()<br><br>    io:println(f * c); // @output -9223372036854775807<br>    io:println((f * g).toBalString()); // @output ()<br><br>    io:println((g * a).toBalString()); // @output ()<br>    io:println((g * b).toBalString()); // @output ()<br>    io:println((g * c).toBalString()); // @output ()<br>    io:println((g * d).toBalString()); // @output ()<br>    io:println((g * e).toBalString()); // @output ()<br>    io:println((g * f).toBalString()); // @output ()<br>    io:println((g * g).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero,<br>             with optional type-descriptors.<br>Labels: multiplicative-expr, int, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting, int:MIN_VALUE<br><br>function init() {<br>    int? a = int:MIN_VALUE;<br>    int? b = -1234;<br>    int? c = -1;<br>    int? d = -0;<br>    int? e = 0;<br>    int? f = 1;<br>    int? g = 60708;<br>    int? h = 9223372036854775807;<br>    int? i = ();<br><br>    io:println(a * d); // @output 0<br>    io:println(a * e); // @output 0<br><br>    io:println(b * d); // @output 0<br>    io:println(b * e); // @output 0<br><br>    io:println(c * d); // @output 0<br>    io:println(c * e); // @output 0<br><br>    io:println(d * a); // @output 0<br>    io:println(d * b); // @output 0<br>    io:println(d * c); // @output 0<br>    io:println(d * d); // @output 0<br>    io:println(d * e); // @output 0<br>    io:println(d * f); // @output 0<br>    io:println(d * g); // @output 0<br>    io:println(d * h); // @output 0<br>    io:println((d * i).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 0<br>    io:println(e * b); // @output 0<br>    io:println(e * c); // @output 0<br>    io:println(e * d); // @output 0<br>    io:println(e * e); // @output 0<br>    io:println(e * f); // @output 0<br>    io:println(e * g); // @output 0<br>    io:println(e * h); // @output 0<br>    io:println((e * i).toBalString()); // @output ()<br><br>    io:println(f * d); // @output 0<br>    io:println(f * e); // @output 0<br><br>    io:println(g * d); // @output 0<br>    io:println(g * e); // @output 0<br><br>    io:println(h * d); // @output 0<br>    io:println(h * e); // @output 0<br><br>    io:println((i * d).toBalString()); // @output ()<br>    io:println((i * e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for positive non-zero integers, <br>             for optional int:Unsigned8.<br>Labels: multiplicative-expr, int:Unsigned8, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned8? a = 1;<br>    int:Unsigned8? b = 2;<br>    int:Unsigned8? c = 3;<br>    int:Unsigned8? d = 86;<br>    int:Unsigned8? e = 255;<br>    int:Unsigned8? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 3<br>    io:println(a * d); // @output 86<br>    io:println(a * e); // @output 255<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 6<br>    io:println(b * d); // @output 172<br>    io:println(b * e); // @output 510<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 3<br>    io:println(c * b); // @output 6<br>    io:println(c * c); // @output 9<br>    io:println(c * d); // @output 258<br>    io:println(c * e); // @output 765<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 86<br>    io:println(d * b); // @output 172<br>    io:println(d * c); // @output 258<br>    io:println(d * d); // @output 7396<br>    io:println(d * e); // @output 21930<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 255<br>    io:println(e * b); // @output 510<br>    io:println(e * c); // @output 765<br>    io:println(e * d); // @output 21930<br>    io:println(e * e); // @output 65025<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero, <br>             for optional int:Unsigned8.<br>Labels: multiplicative-expr, int:Unsigned8, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned8? a = 0;<br>    int:Unsigned8? b = 1;<br>    int:Unsigned8? c = 128;<br>    int:Unsigned8? d = 255;<br>    int:Unsigned8? e = ();<br><br>    io:println(a * a); // @output 0<br><br>    io:println(a * b); // @output 0<br>    io:println(a * c); // @output 0<br>    io:println(a * d); // @output 0<br>    io:println((a * e).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 0<br>    io:println(c * a); // @output 0<br>    io:println(d * a); // @output 0<br>    io:println((e * a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 1 for integer multiplication overflow, where one operand is of type optional int:Unsigned8.<br>Labels: multiplicative-expr, int:Unsigned8, optional-type, DecimalNumber, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned8? a = 255;<br>    int b = 36170086419038337;    <br>    int? _ = a * b; // @panic integer overflow on multiplication<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 2 for integer multiplication overflow, where one operand is of type optional int:Unsigned8.<br>Labels: multiplicative-expr, int:Unsigned8, optional-type, DecimalNumber, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int? a = -461168601842738791;<br>    int:Unsigned8? b = 20;  <br>    int? _ = a * b; // @panic integer overflow on multiplication<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for positive non-zero integers, for optional byte.<br>Labels: multiplicative-expr, byte, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    byte? a = 1;<br>    byte? b = 2;<br>    byte? c = 3;<br>    byte? d = 86;<br>    byte? e = 255;<br>    byte? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 3<br>    io:println(a * d); // @output 86<br>    io:println(a * e); // @output 255<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 6<br>    io:println(b * d); // @output 172<br>    io:println(b * e); // @output 510<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 3<br>    io:println(c * b); // @output 6<br>    io:println(c * c); // @output 9<br>    io:println(c * d); // @output 258<br>    io:println(c * e); // @output 765<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 86<br>    io:println(d * b); // @output 172<br>    io:println(d * c); // @output 258<br>    io:println(d * d); // @output 7396<br>    io:println(d * e); // @output 21930<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 255<br>    io:println(e * b); // @output 510<br>    io:println(e * c); // @output 765<br>    io:println(e * d); // @output 21930<br>    io:println(e * e); // @output 65025<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero, for optional byte.<br>Labels: multiplicative-expr, byte, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    byte? a = 0;<br>    byte? b = 1;<br>    byte? c = 128;<br>    byte? d = 255;<br>    byte? e = ();<br><br>    io:println(a * a); // @output 0<br><br>    io:println(a * b); // @output 0<br>    io:println(a * c); // @output 0<br>    io:println(a * d); // @output 0<br>    io:println((a * e).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 0<br>    io:println(c * a); // @output 0<br>    io:println(d * a); // @output 0<br>    io:println((e * a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for positive non-zero integers, for optional int:Unsigned16.<br>Labels: multiplicative-expr, int:Unsigned16, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned16? a = 1;<br>    int:Unsigned16? b = 2;<br>    int:Unsigned16? c = 5;<br>    int:Unsigned16? d = 40123;<br>    int:Unsigned16? e = 65535;<br>    int:Unsigned16? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 5<br>    io:println(a * d); // @output 40123<br>    io:println(a * e); // @output 65535<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 10<br>    io:println(b * d); // @output 80246<br>    io:println(b * e); // @output 131070<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 5<br>    io:println(c * b); // @output 10<br>    io:println(c * c); // @output 25<br>    io:println(c * d); // @output 200615<br>    io:println(c * e); // @output 327675<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 40123<br>    io:println(d * b); // @output 80246<br>    io:println(d * c); // @output 200615<br>    io:println(d * d); // @output 1609855129<br>    io:println(d * e); // @output 2629460805<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 65535<br>    io:println(e * b); // @output 131070<br>    io:println(e * c); // @output 327675<br>    io:println(e * d); // @output 2629460805<br>    io:println(e * e); // @output 4294836225<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero, for optional int:Unsigned16.<br>Labels: multiplicative-expr, int:Unsigned16, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned16? a = 0;<br>    int:Unsigned16? b = 1;<br>    int:Unsigned16? c = 128;<br>    int:Unsigned16? d = 255;<br>    int:Unsigned16? e = ();<br><br>    io:println(a * a); // @output 0<br><br>    io:println(a * b); // @output 0<br>    io:println(a * c); // @output 0<br>    io:println(a * d); // @output 0<br>    io:println((a * e).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 0<br>    io:println(c * a); // @output 0<br>    io:println(d * a); // @output 0<br>    io:println((e * a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 2 for integer multiplication overflow, where one operand is of type optional int:Unsigned16.<br>Labels: multiplicative-expr, int:Unsigned16, optional-type, DecimalNumber, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int a = -30744573456182586;<br>    int:Unsigned16? b = 301;  <br>    int? _ = a * b; // @panic integer overflow on multiplication<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for positive non-zero integers, for optional int:Unsigned32.<br>Labels: multiplicative-expr, int:Unsigned32, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned32? a = 1;<br>    int:Unsigned32? b = 2;<br>    int:Unsigned32? c = 10;<br>    int:Unsigned32? d = 12034;<br>    int:Unsigned32? e = 429496729;<br>    int:Unsigned32? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 10<br>    io:println(a * d); // @output 12034<br>    io:println(a * e); // @output 429496729<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 20<br>    io:println(b * d); // @output 24068<br>    io:println(b * e); // @output 858993458<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 10<br>    io:println(c * b); // @output 20<br>    io:println(c * c); // @output 100<br>    io:println(c * d); // @output 120340<br>    io:println(c * e); // @output 4294967290<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 12034<br>    io:println(d * b); // @output 24068<br>    io:println(d * c); // @output 120340<br>    io:println(d * d); // @output 144817156<br>    io:println(d * e); // @output 5168563636786<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 429496729<br>    io:println(e * b); // @output 858993458<br>    io:println(e * c); // @output 4294967290<br>    io:println(e * d); // @output 5168563636786<br>    io:println(e * e); // @output 184467440221699441<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero, for optional int:Unsigned32.<br>Labels: multiplicative-expr, int:Unsigned32, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Unsigned32? a = 0;<br>    int:Unsigned32? b = 1;<br>    int:Unsigned32? c = 1259273;<br>    int:Unsigned32? d = 4294967295;<br>    int:Unsigned32? e = ();<br><br>    io:println(a * a); // @output 0<br><br>    io:println(a * b); // @output 0<br>    io:println(a * c); // @output 0<br>    io:println(a * d); // @output 0<br>    io:println((a * e).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 0<br>    io:println(c * a); // @output 0<br>    io:println(d * a); // @output 0<br>    io:println((e * a).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for positive non-zero integers, for optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Signed8? a = 1;<br>    int:Signed8? b = 2;<br>    int:Signed8? c = 10;<br>    int:Signed8? d = 100;<br>    int:Signed8? e = 127;<br>    int:Signed8? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 10<br>    io:println(a * d); // @output 100<br>    io:println(a * e); // @output 127<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 20<br>    io:println(b * d); // @output 200<br>    io:println(b * e); // @output 254<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 10<br>    io:println(c * b); // @output 20<br>    io:println(c * c); // @output 100<br>    io:println(c * d); // @output 1000<br>    io:println(c * e); // @output 1270<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 100<br>    io:println(d * b); // @output 200<br>    io:println(d * c); // @output 1000<br>    io:println(d * d); // @output 10000<br>    io:println(d * e); // @output 12700<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 127<br>    io:println(e * b); // @output 254<br>    io:println(e * c); // @output 1270<br>    io:println(e * d); // @output 12700<br>    io:println(e * e); // @output 16129<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for negative non-zero integers, for optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed8? a = -1;<br>    int:Signed8? b = -2;<br>    int:Signed8? c = -100;<br>    int:Signed8? d = -120;<br>    int:Signed8? e = -128;<br>    int:Signed8? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 100<br>    io:println(a * d); // @output 120<br>    io:println(a * e); // @output 128<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 200<br>    io:println(b * d); // @output 240<br>    io:println(b * e); // @output 256<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 100<br>    io:println(c * b); // @output 200<br>    io:println(c * c); // @output 10000<br>    io:println(c * d); // @output 12000<br>    io:println(c * e); // @output 12800<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 120<br>    io:println(d * b); // @output 240<br>    io:println(d * c); // @output 12000<br>    io:println(d * d); // @output 14400<br>    io:println(d * e); // @output 15360<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 128<br>    io:println(e * b); // @output 256<br>    io:println(e * c); // @output 12800<br>    io:println(e * d); // @output 15360<br>    io:println(e * e); // @output 16384<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero, for optional int:Signed8.<br>Labels: multiplicative-expr, int:Signed8, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed8? a = -128;<br>    int:Signed8? b = -100;<br>    int:Signed8? c = -1;<br>    int:Signed8? d = -0;<br>    int:Signed8? e = 0;<br>    int:Signed8? f = 1;<br>    int:Signed8? g = 100;<br>    int:Signed8? h = 127;<br>    int:Signed8? i = ();<br><br>    io:println(a * d); // @output 0<br>    io:println(a * e); // @output 0<br><br>    io:println(b * d); // @output 0<br>    io:println(b * e); // @output 0<br><br>    io:println(c * d); // @output 0<br>    io:println(c * e); // @output 0<br><br>    io:println(d * a); // @output 0<br>    io:println(d * b); // @output 0<br>    io:println(d * c); // @output 0<br>    io:println(d * d); // @output 0<br>    io:println(d * e); // @output 0<br>    io:println(d * f); // @output 0<br>    io:println(d * g); // @output 0<br>    io:println(d * h); // @output 0<br>    io:println((d * i).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 0<br>    io:println(e * b); // @output 0<br>    io:println(e * c); // @output 0<br>    io:println(e * d); // @output 0<br>    io:println(e * e); // @output 0<br>    io:println(e * f); // @output 0<br>    io:println(e * g); // @output 0<br>    io:println(e * h); // @output 0<br>    io:println((e * i).toBalString()); // @output ()<br><br>    io:println(f * d); // @output 0<br>    io:println(f * e); // @output 0<br><br>    io:println(g * d); // @output 0<br>    io:println(g * e); // @output 0<br><br>    io:println(h * d); // @output 0<br>    io:println(h * e); // @output 0<br><br>    io:println((i * d).toBalString()); // @output ()<br>    io:println((i * e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for positive non-zero integers, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, nil-literal, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int:Signed16? a = 1;<br>    int:Signed16? b = 2;<br>    int:Signed16? c = 10;<br>    int:Signed16? d = 12345;<br>    int:Signed16? e = 32767;<br>    int:Signed16? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 10<br>    io:println(a * d); // @output 12345<br>    io:println(a * e); // @output 32767<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 20<br>    io:println(b * d); // @output 24690<br>    io:println(b * e); // @output 65534<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 10<br>    io:println(c * b); // @output 20<br>    io:println(c * c); // @output 100<br>    io:println(c * d); // @output 123450<br>    io:println(c * e); // @output 327670<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 12345<br>    io:println(d * b); // @output 24690<br>    io:println(d * c); // @output 123450<br>    io:println(d * d); // @output 152399025<br>    io:println(d * e); // @output 404508615<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 32767<br>    io:println(e * b); // @output 65534<br>    io:println(e * c); // @output 327670<br>    io:println(e * d); // @output 404508615<br>    io:println(e * e); // @output 1073676289<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for negative non-zero integers, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed16? a = -1;<br>    int:Signed16? b = -2;<br>    int:Signed16? c = -100;<br>    int:Signed16? d = -20000;<br>    int:Signed16? e = -32768;<br>    int:Signed16? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 100<br>    io:println(a * d); // @output 20000<br>    io:println(a * e); // @output 32768<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 200<br>    io:println(b * d); // @output 40000<br>    io:println(b * e); // @output 65536<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 100<br>    io:println(c * b); // @output 200<br>    io:println(c * c); // @output 10000<br>    io:println(c * d); // @output 2000000<br>    io:println(c * e); // @output 3276800<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 20000<br>    io:println(d * b); // @output 40000<br>    io:println(d * c); // @output 2000000<br>    io:println(d * d); // @output 400000000<br>    io:println(d * e); // @output 655360000<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 32768<br>    io:println(e * b); // @output 65536<br>    io:println(e * c); // @output 3276800<br>    io:println(e * d); // @output 655360000<br>    io:println(e * e); // @output 1073741824<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed16? a = -32768;<br>    int:Signed16? b = -100;<br>    int:Signed16? c = -1;<br>    int:Signed16? d = -0;<br>    int:Signed16? e = 0;<br>    int:Signed16? f = 1;<br>    int:Signed16? g = 1100;<br>    int:Signed16? h = 32767;<br>    int:Signed16? i = ();<br><br>    io:println(a * d); // @output 0<br>    io:println(a * e); // @output 0<br><br>    io:println(b * d); // @output 0<br>    io:println(b * e); // @output 0<br><br>    io:println(c * d); // @output 0<br>    io:println(c * e); // @output 0<br><br>    io:println(d * a); // @output 0<br>    io:println(d * b); // @output 0<br>    io:println(d * c); // @output 0<br>    io:println(d * d); // @output 0<br>    io:println(d * e); // @output 0<br>    io:println(d * f); // @output 0<br>    io:println(d * g); // @output 0<br>    io:println(d * h); // @output 0<br>    io:println((d * i).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 0<br>    io:println(e * b); // @output 0<br>    io:println(e * c); // @output 0<br>    io:println(e * d); // @output 0<br>    io:println(e * e); // @output 0<br>    io:println(e * f); // @output 0<br>    io:println(e * g); // @output 0<br>    io:println(e * h); // @output 0<br>    io:println((e * i).toBalString()); // @output ()<br><br>    io:println(f * d); // @output 0<br>    io:println(f * e); // @output 0<br><br>    io:println(g * d); // @output 0<br>    io:println(g * e); // @output 0<br><br>    io:println(h * d); // @output 0<br>    io:println(h * e); // @output 0<br><br>    io:println((i * d).toBalString()); // @output ()<br>    io:println((i * e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test 1 for integer multiplication overflow, for optional int:Signed16.<br>Labels: multiplicative-expr, int:Signed16, optional-type, DecimalNumber, value:toBalString, numeric-nil-lifting<br><br>function init() {<br>    int? a = 281483566907401;<br>    int:Signed16? b = 32767;<br>    int? _ = a * b; // @panic integer overflow on multiplication<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for positive non-zero integers, for optional int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed32? a = 1;<br>    int:Signed32? b = 2;<br>    int:Signed32? c = 10;<br>    int:Signed32? d = 1000;<br>    int:Signed32? e = 2147483647;<br>    int:Signed32? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 10<br>    io:println(a * d); // @output 1000<br>    io:println(a * e); // @output 2147483647<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 20<br>    io:println(b * d); // @output 2000<br>    io:println(b * e); // @output 4294967294<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 10<br>    io:println(c * b); // @output 20<br>    io:println(c * c); // @output 100<br>    io:println(c * d); // @output 10000<br>    io:println(c * e); // @output 21474836470<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 1000<br>    io:println(d * b); // @output 2000<br>    io:println(d * c); // @output 10000<br>    io:println(d * d); // @output 1000000<br>    io:println(d * e); // @output 2147483647000<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 2147483647<br>    io:println(e * b); // @output 4294967294<br>    io:println(e * c); // @output 21474836470<br>    io:println(e * d); // @output 2147483647000<br>    io:println(e * e); // @output 4611686014132420609<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for negative non-zero integers, for optional int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed32? a = -1;<br>    int:Signed32? b = -2;<br>    int:Signed32? c = -100;<br>    int:Signed32? d = -20000;<br>    int:Signed32? e = -2147483648;<br>    int:Signed32? f = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println(a * c); // @output 100<br>    io:println(a * d); // @output 20000<br>    io:println(a * e); // @output 2147483648<br>    io:println((a * f).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println(b * c); // @output 200<br>    io:println(b * d); // @output 40000<br>    io:println(b * e); // @output 4294967296<br>    io:println((b * f).toBalString()); // @output ()<br><br>    io:println(c * a); // @output 100<br>    io:println(c * b); // @output 200<br>    io:println(c * c); // @output 10000<br>    io:println(c * d); // @output 2000000<br>    io:println(c * e); // @output 214748364800<br>    io:println((c * f).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 20000<br>    io:println(d * b); // @output 40000<br>    io:println(d * c); // @output 2000000<br>    io:println(d * d); // @output 400000000<br>    io:println(d * e); // @output 42949672960000<br>    io:println((d * f).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 2147483648<br>    io:println(e * b); // @output 4294967296<br>    io:println(e * c); // @output 214748364800<br>    io:println(e * d); // @output 42949672960000<br>    io:println(e * e); // @output 4611686018427387904<br>    io:println((e * f).toBalString()); // @output ()<br><br>    io:println((f * a).toBalString()); // @output ()<br>    io:println((f * b).toBalString()); // @output ()<br>    io:println((f * c).toBalString()); // @output ()<br>    io:println((f * d).toBalString()); // @output ()<br>    io:println((f * e).toBalString()); // @output ()<br>    io:println((f * f).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero, for optional int:Signed32.<br>Labels: multiplicative-expr, int:Signed32, optional-type, DecimalNumber, nil-literal, value:toBalString, unary-minus, numeric-nil-lifting<br><br>function init() {<br>    int:Signed32? a = -2147483648;<br>    int:Signed32? b = -12342340;<br>    int:Signed32? c = -1;<br>    int:Signed32? d = -0;<br>    int:Signed32? e = 0;<br>    int:Signed32? f = 1;<br>    int:Signed32? g = 139456264;<br>    int:Signed32? h = 2147483647;<br>    int:Signed32? i = ();<br><br>    io:println(a * d); // @output 0<br>    io:println(a * e); // @output 0<br><br>    io:println(b * d); // @output 0<br>    io:println(b * e); // @output 0<br><br>    io:println(c * d); // @output 0<br>    io:println(c * e); // @output 0<br><br>    io:println(d * a); // @output 0<br>    io:println(d * b); // @output 0<br>    io:println(d * c); // @output 0<br>    io:println(d * d); // @output 0<br>    io:println(d * e); // @output 0<br>    io:println(d * f); // @output 0<br>    io:println(d * g); // @output 0<br>    io:println(d * h); // @output 0<br>    io:println((d * i).toBalString()); // @output ()<br><br>    io:println(e * a); // @output 0<br>    io:println(e * b); // @output 0<br>    io:println(e * c); // @output 0<br>    io:println(e * d); // @output 0<br>    io:println(e * e); // @output 0<br>    io:println(e * f); // @output 0<br>    io:println(e * g); // @output 0<br>    io:println(e * h); // @output 0<br>    io:println((e * i).toBalString()); // @output ()<br><br>    io:println(f * d); // @output 0<br>    io:println(f * e); // @output 0<br><br>    io:println(g * d); // @output 0<br>    io:println(g * e); // @output 0<br><br>    io:println(h * d); // @output 0<br>    io:println(h * e); // @output 0<br><br>    io:println((i * d).toBalString()); // @output ()<br>    io:println((i * e).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for positive non-zero integers,<br>             for user-defined subtype of int.<br>Labels: multiplicative-expr, union-type, singleton-type, optional-type, DecimalNumber, nil-literal, module-type-defn, unary-minus, value:toBalString, numeric-nil-lifting<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    Ints? a = 1;<br>    Ints? b = 2;<br>    Ints? c = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println((a * c).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println((b * c).toBalString()); // @output ()<br><br>    io:println((c * a).toBalString()); // @output ()<br>    io:println((c * b).toBalString()); // @output ()<br>    io:println((c * c).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, for negative non-zero integers,<br>             for user-defined subtype of int.<br>Labels: multiplicative-expr, union-type, optional-type, DecimalNumber, nil-literal, module-type-defn, unary-minus, value:toBalString, numeric-nil-lifting<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    Ints? a = -1;<br>    Ints? b = -2;<br>    Ints? c = ();<br><br>    io:println(a * a); // @output 1<br>    io:println(a * b); // @output 2<br>    io:println((a * c).toBalString()); // @output ()<br><br>    io:println(b * a); // @output 2<br>    io:println(b * b); // @output 4<br>    io:println((b * c).toBalString()); // @output ()<br><br>    io:println((c * a).toBalString()); // @output ()<br>    io:println((c * b).toBalString()); // @output ()<br>    io:println((c * c).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-overflow scenarios, where at least one operand is zero, for<br>             user-defined subtype of int.<br>Labels: multiplicative-expr, union-type, singleton-type, optional-type, DecimalNumber, nil-literal, module-type-defn, unary-minus, value:toBalString, numeric-nil-lifting<br><br>type Ints -2|-1|0|1|2;<br><br>function init() {<br>    Ints? a = -2;<br>    Ints? b = -1;<br>    Ints? c = -0;<br>    Ints? d = 0;<br>    Ints? e = 1;<br>    Ints? f = 2;<br>    Ints? g = ();<br><br>    io:println(a * c); // @output 0<br>    io:println(a * d); // @output 0<br><br>    io:println(b * c); // @output 0<br>    io:println(b * d); // @output 0<br><br>    io:println(c * a); // @output 0<br>    io:println(c * b); // @output 0<br>    io:println(c * c); // @output 0<br>    io:println(c * d); // @output 0<br>    io:println(c * e); // @output 0<br>    io:println(c * f); // @output 0<br>    io:println((c * g).toBalString()); // @output ()<br><br>    io:println(d * a); // @output 0<br>    io:println(d * b); // @output 0<br>    io:println(d * c); // @output 0<br>    io:println(d * d); // @output 0<br>    io:println(d * e); // @output 0<br>    io:println(d * f); // @output 0<br>    io:println((d * g).toBalString()); // @output ()<br><br>    io:println(e * c); // @output 0<br>    io:println(e * d); // @output 0<br><br>    io:println(f * c); // @output 0<br>    io:println(f * d); // @output 0<br><br>    io:println((g * c).toBalString()); // @output ()<br>    io:println((g * d).toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test function and method call as integer multiplication operands.<br>Labels: multiplicative-expr, int, DecimalNumber, function-call-expr, module-class-defn, explicit-new-expr, method-call-expr <br><br>function init() {<br>    Class f = new Class();<br>    int g = f.getInt() * getInt();<br>    io:println(g); // @output 360<br>}<br><br>function getInt() returns int {<br>    return 2 * 3;<br>}<br><br>class Class {<br>    function getInt() returns int {<br>        return 60;<br>    }<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test let expression in integer multiplication operands.<br>Labels: multiplicative-expr, int, DecimalNumber, let-expr <br><br>function init() {<br>    int h = (let int h1 = 3 * 4 in h1) * 5;<br>    io:println(h); // @output 60<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test unary expressions in integer multiplication operands.<br>Labels: multiplicative-expr, int, DecimalNumber, unary-plus, unary-minus, unary-complement <br><br>function init() {<br>    int k = +4 * -3;<br>    io:println(k); // @output -12<br><br>    int l = -(-2 * 5);<br>    io:println(l); // @output 10<br><br>    int m = ~(2 * 5);<br>    io:println(m); // @output -11<br><br>    int n = ~2 * 5;<br>    io:println(n); // @output -15<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test conditional expressions as integer multiplication operands.<br>Labels: multiplicative-expr, int, DecimalNumber, nil-literal, ternary-conditional-expr, binary-conditional-expr, union-type, error, optional-type<br><br>function init() {<br>    int|error a = 12;<br>    int? b = ();<br>    int c = (a is error ? 2 : a) * (b ?: 13);<br>    io:println(c); // @output 156<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test checking expressions as integer multiplication operands.<br>Labels: multiplicative-expr, int, DecimalNumber, check, checkpanic, union-type, error<br><br>function init() returns error? {<br>    int|error a = 12;<br>    int c = check a * checkpanic a;<br>    io:println(c); // @output 144<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication with operands of different int subtypes.<br>Labels: multiplicative-expr, int, DecimalNumber, byte, int:Signed8, int:Signed16,<br>        int:Signed32, int:Unsigned8, int:Unsigned16, int:Unsigned32, module-type-defn, union-type, singleton-type<br><br>type Ints -9|9;<br><br>function init() returns error? {<br>    int a = -1;<br>    byte b = 2;<br>    int:Signed8 c = -3;<br>    int:Signed16 d = 4;<br>    int:Signed32 e = -5;<br>    int:Unsigned8 f = 6;<br>    int:Unsigned16 g = 7;<br>    int:Unsigned32 h = 8;<br>    Ints i = -9;<br><br>    int v = a * b;<br>    io:println(v); // @output -2<br><br>    v = a * c;<br>    io:println(v); // @output 3<br><br>    v = a * d;<br>    io:println(v); // @output -4<br><br>    v = a * e;<br>    io:println(v); // @output 5<br><br>    v = a * f;<br>    io:println(v); // @output -6<br><br>    v = a * g;<br>    io:println(v); // @output -7<br><br>    v = a * h;<br>    io:println(v); // @output -8<br><br>    v = a * i;<br>    io:println(v); // @output 9<br><br>    v = b * a;<br>    io:println(v); // @output -2<br><br>    v = b * c;<br>    io:println(v); // @output -6<br><br>    v = b * d;<br>    io:println(v); // @output 8<br><br>    v = b * e;<br>    io:println(v); // @output -10<br><br>    v = b * f;<br>    io:println(v); // @output 12<br><br>    v = b * g;<br>    io:println(v); // @output 14<br><br>    v = b * h;<br>    io:println(v); // @output 16<br><br>    v = b * i;<br>    io:println(v); // @output -18<br><br>    v = c * a;<br>    io:println(v); // @output 3<br><br>    v = c * b;<br>    io:println(v); // @output -6<br><br>    v = c * d;<br>    io:println(v); // @output -12<br><br>    v = c * e;<br>    io:println(v); // @output 15<br><br>    v = c * f;<br>    io:println(v); // @output -18<br><br>    v = c * g;<br>    io:println(v); // @output -21<br><br>    v = c * h;<br>    io:println(v); // @output -24<br><br>    v = c * i;<br>    io:println(v); // @output 27<br><br>    v = d * a;<br>    io:println(v); // @output -4<br><br>    v = d * b;<br>    io:println(v); // @output 8<br><br>    v = d * c;<br>    io:println(v); // @output -12<br><br>    v = d * e;<br>    io:println(v); // @output -20<br><br>    v = d * f;<br>    io:println(v); // @output 24<br><br>    v = d * g;<br>    io:println(v); // @output 28<br><br>    v = d * h;<br>    io:println(v); // @output 32<br><br>    v = d * i;<br>    io:println(v); // @output -36<br><br>    v = e * a;<br>    io:println(v); // @output 5<br><br>    v = e * b;<br>    io:println(v); // @output -10<br><br>    v = e * c;<br>    io:println(v); // @output 15<br><br>    v = e * d;<br>    io:println(v); // @output -20<br><br>    v = e * f;<br>    io:println(v); // @output -30<br><br>    v = e * g;<br>    io:println(v); // @output -35<br><br>    v = e * h;<br>    io:println(v); // @output -40<br><br>    v = e * i;<br>    io:println(v); // @output 45<br><br>    v = f * a;<br>    io:println(v); // @output -6<br><br>    v = f * b;<br>    io:println(v); // @output 12<br><br>    v = f * c;<br>    io:println(v); // @output -18<br><br>    v = f * d;<br>    io:println(v); // @output 24<br><br>    v = f * e;<br>    io:println(v); // @output -30<br><br>    v = f * g;<br>    io:println(v); // @output 42<br><br>    v = f * h;<br>    io:println(v); // @output 48<br><br>    v = f * i;<br>    io:println(v); // @output -54<br><br>    v = g * a;<br>    io:println(v); // @output -7<br><br>    v = g * b;<br>    io:println(v); // @output 14<br><br>    v = g * c;<br>    io:println(v); // @output -21<br><br>    v = g * d;<br>    io:println(v); // @output 28<br><br>    v = g * e;<br>    io:println(v); // @output -35<br><br>    v = g * f;<br>    io:println(v); // @output 42<br><br>    v = g * h;<br>    io:println(v); // @output 56<br><br>    v = g * i;<br>    io:println(v); // @output -63<br><br>    v = h * a;<br>    io:println(v); // @output -8<br><br>    v = h * b;<br>    io:println(v); // @output 16<br><br>    v = h * c;<br>    io:println(v); // @output -24<br><br>    v = h * d;<br>    io:println(v); // @output 32<br><br>    v = h * e;<br>    io:println(v); // @output -40<br><br>    v = h * f;<br>    io:println(v); // @output 48<br><br>    v = h * g;<br>    io:println(v); // @output 56<br><br>    v = h * i;<br>    io:println(v); // @output -72<br><br>    v = i * a;<br>    io:println(v); // @output 9<br><br>    v = i * b;<br>    io:println(v); // @output -18<br><br>    v = i * c;<br>    io:println(v); // @output 27<br><br>    v = i * d;<br>    io:println(v); // @output -36<br><br>    v = i * e;<br>    io:println(v); // @output 45<br><br>    v = i * f;<br>    io:println(v); // @output -54<br><br>    v = i * g;<br>    io:println(v); // @output -63<br><br>    v = i * h;<br>    io:println(v); // @output -72<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test 1 for integer multiplication with operands of different optional int subtypes.<br>Labels: multiplicative-expr, int, DecimalNumber, byte, int:Signed8, int:Signed16,<br>        int:Signed32, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, module-type-defn, union-type, singleton-type, numeric-nil-lifting<br><br>type Ints -9|9;<br><br>function init() returns error? {<br>    int? a = -1;<br>    byte? b = 2;<br>    int:Signed8? c = -3;<br>    int:Signed16? d = 4;<br>    int:Signed32? e = -5;<br>    int:Unsigned8? f = 6;<br>    int:Unsigned16? g = 7;<br>    int:Unsigned32? h = 8;<br>    Ints i = -9;<br>    int? j = ();<br><br>    int? v = a * b;<br>    io:println(v); // @output -2<br><br>    v = a * c;<br>    io:println(v); // @output 3<br><br>    v = a * d;<br>    io:println(v); // @output -4<br><br>    v = a * e;<br>    io:println(v); // @output 5<br><br>    v = a * f;<br>    io:println(v); // @output -6<br><br>    v = a * g;<br>    io:println(v); // @output -7<br><br>    v = a * h;<br>    io:println(v); // @output -8<br><br>    v = a * i;<br>    io:println(v); // @output 9<br><br>    v = a * j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = b * a;<br>    io:println(v); // @output -2<br><br>    v = b * c;<br>    io:println(v); // @output -6<br><br>    v = b * d;<br>    io:println(v); // @output 8<br><br>    v = b * e;<br>    io:println(v); // @output -10<br><br>    v = b * f;<br>    io:println(v); // @output 12<br><br>    v = b * g;<br>    io:println(v); // @output 14<br><br>    v = b * h;<br>    io:println(v); // @output 16<br><br>    v = b * i;<br>    io:println(v); // @output -18<br><br>    v = b * j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = c * a;<br>    io:println(v); // @output 3<br><br>    v = c * b;<br>    io:println(v); // @output -6<br><br>    v = c * d;<br>    io:println(v); // @output -12<br><br>    v = c * e;<br>    io:println(v); // @output 15<br><br>    v = c * f;<br>    io:println(v); // @output -18<br><br>    v = c * g;<br>    io:println(v); // @output -21<br><br>    v = c * h;<br>    io:println(v); // @output -24<br><br>    v = c * i;<br>    io:println(v); // @output 27<br><br>    v = c * j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = d * a;<br>    io:println(v); // @output -4<br><br>    v = d * b;<br>    io:println(v); // @output 8<br><br>    v = d * c;<br>    io:println(v); // @output -12<br><br>    v = d * e;<br>    io:println(v); // @output -20<br><br>    v = d * f;<br>    io:println(v); // @output 24<br><br>    v = d * g;<br>    io:println(v); // @output 28<br><br>    v = d * h;<br>    io:println(v); // @output 32<br><br>    v = d * i;<br>    io:println(v); // @output -36<br><br>    v = d * j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = e * a;<br>    io:println(v); // @output 5<br><br>    v = e * b;<br>    io:println(v); // @output -10<br><br>    v = e * c;<br>    io:println(v); // @output 15<br><br>    v = e * d;<br>    io:println(v); // @output -20<br><br>    v = e * f;<br>    io:println(v); // @output -30<br><br>    v = e * g;<br>    io:println(v); // @output -35<br><br>    v = e * h;<br>    io:println(v); // @output -40<br><br>    v = e * i;<br>    io:println(v); // @output 45<br><br>    v = e * j;<br>    io:println(v.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test 2 for integer multiplication with operands of different optional int subtypes.<br>Labels: multiplicative-expr, int, DecimalNumber, byte, int:Signed8, int:Signed16,<br>        int:Signed32, int:Unsigned8, int:Unsigned16, int:Unsigned32, nil-literal, module-type-defn, union-type, numeric-nil-lifting<br><br>type Ints -9|9;<br><br>function init() returns error? {<br>    int? a = -1;<br>    byte? b = 2;<br>    int:Signed8? c = -3;<br>    int:Signed16? d = 4;<br>    int:Signed32? e = -5;<br>    int:Unsigned8? f = 6;<br>    int:Unsigned16? g = 7;<br>    int:Unsigned32? h = 8;<br>    Ints? i = -9;<br>    int? j = ();<br><br>    int? v = f * a;<br>    io:println(v); // @output -6<br><br>    v = f * b;<br>    io:println(v); // @output 12<br><br>    v = f * c;<br>    io:println(v); // @output -18<br><br>    v = f * d;<br>    io:println(v); // @output 24<br><br>    v = f * e;<br>    io:println(v); // @output -30<br><br>    v = f * g;<br>    io:println(v); // @output 42<br><br>    v = f * h;<br>    io:println(v); // @output 48<br><br>    v = f * i;<br>    io:println(v); // @output -54<br><br>    v = f * j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = g * a;<br>    io:println(v); // @output -7<br><br>    v = g * b;<br>    io:println(v); // @output 14<br><br>    v = g * c;<br>    io:println(v); // @output -21<br><br>    v = g * d;<br>    io:println(v); // @output 28<br><br>    v = g * e;<br>    io:println(v); // @output -35<br><br>    v = g * f;<br>    io:println(v); // @output 42<br><br>    v = g * h;<br>    io:println(v); // @output 56<br><br>    v = g * i;<br>    io:println(v); // @output -63<br><br>    v = g * j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = h * a;<br>    io:println(v); // @output -8<br><br>    v = h * b;<br>    io:println(v); // @output 16<br><br>    v = h * c;<br>    io:println(v); // @output -24<br><br>    v = h * d;<br>    io:println(v); // @output 32<br><br>    v = h * e;<br>    io:println(v); // @output -40<br><br>    v = h * f;<br>    io:println(v); // @output 48<br><br>    v = h * g;<br>    io:println(v); // @output 56<br><br>    v = h * i;<br>    io:println(v); // @output -72<br><br>    v = h * j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = i * a;<br>    io:println(v); // @output 9<br><br>    v = i * b;<br>    io:println(v); // @output -18<br><br>    v = i * c;<br>    io:println(v); // @output 27<br><br>    v = i * d;<br>    io:println(v); // @output -36<br><br>    v = i * e;<br>    io:println(v); // @output 45<br><br>    v = i * f;<br>    io:println(v); // @output -54<br><br>    v = i * g;<br>    io:println(v); // @output -63<br><br>    v = i * h;<br>    io:println(v); // @output -72<br><br>    v = i * j;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j * a;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j * b;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j * c;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j * d;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j * e;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j * f;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j * g;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j * h;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = j * i;<br>    io:println(v.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication with optional int operand's type written in different ways.<br>Labels: multiplicative-expr, int, DecimalNumber, nil-literal, optional-type, module-type-defn, union-type, singleton-type, value:toBalString<br><br>type T1 1|()|2;<br><br>type T2 1|2?;<br><br>function init() {<br>    T1 a = 1;<br>    T2 b = 2;<br>    ()|int c = ();<br><br>    int? v = a * a;<br>    io:println(v); // @output 1<br><br>    v = a * b;<br>    io:println(v); // @output 2<br><br>    v = a * c;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = b * b;<br>    io:println(v); // @output 4<br><br>    v = b * c;<br>    io:println(v.toBalString()); // @output ()<br><br>    v = c * c;<br>    io:println(v.toBalString()); // @output ()<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test integer multiplication non-panic scenarios at module-level.<br>Labels: multiplicative-expr, int, DecimalNumber<br><br>int a = 10;<br>int b = 2;<br>int c = a * b;<br>int d = a * 3;<br>int e = 21 * 3;<br><br>function init() {<br>    io:println(c); // @output 20<br>    io:println(d); // @output 30<br>    io:println(e); // @output 63<br>}<br></pre>
<pre>Test-Case: panic<br>Description: Test integer multiplication panic at module-level.<br>Labels: multiplicative-expr, int:MIN_VALUE, DecimalNumber, unary-minus<br><br>int a = 9223372036854775802 * 2; // @panic integer overflow on multiplication</pre>
<h3>string_addition.balt</h3>
<pre>Test-Case: error<br>Description: Test string concatenation static type via invalid assignment with var.<br>Labels: additive-expr, string, string:Char, int, union-type, singleton-type, module-type-defn, var<br><br>type Strings "a"|"bc";<br><br>function errorFunction(string a, string:Char b, Strings c) {<br>    var d = a + a;<br>    int v1 = d; // @error incompatible types: expected int found string<br>    string:Char v2 = d; // @error incompatible types: expected string:Char found string<br><br>    var e = a + b;<br>    v1 = e; // @error incompatible types: expected int found string<br>    v2 = e; // @error incompatible types: expected string:Char found string<br><br>    var f = a + c;<br>    v1 = f; // @error incompatible types: expected int found string<br>    v2 = f; // @error incompatible types: expected string:Char found string<br><br>    var g = b + a;<br>    v1 = g; // @error incompatible types: expected int found string<br>    v2 = g; // @error incompatible types: expected string:Char found string<br><br>    var h = b + b;<br>    v1 = h; // @error incompatible types: expected int found string<br>    v2 = h; // @error incompatible types: expected string:Char found string<br><br>    var i = b + c;<br>    v1 = i; // @error incompatible types: expected int found string<br>    v2 = i; // @error incompatible types: expected string:Char found string<br><br>    var j = c + a;<br>    v1 = j; // @error incompatible types: expected int found string<br>    v2 = j; // @error incompatible types: expected string:Char found string<br><br>    var k = c + b;<br>    v1 = k; // @error incompatible types: expected int found string<br>    v2 = k; // @error incompatible types: expected string:Char found string<br><br>    var l = c + c;<br>    v1 = l; // @error incompatible types: expected int found string<br>    v2 = l; // @error incompatible types: expected string:Char found string<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation with var.<br>Labels: additive-expr, string, string:Char, union-type, singleton-type, module-type-defn, var<br><br>type Strings "a"|"bc";<br><br>function init() {<br>    string a = "foo";<br>    string:Char b = "A";<br>    Strings c = "bc";<br><br>    var d = a + a;<br>    io:println(d); // @output foofoo<br><br>    var e = a + b;<br>    io:println(e); // @output fooA<br><br>    var f = a + c;<br>    io:println(f); // @output foobc<br><br>    var g = b + c;<br>    io:println(g); // @output Abc<br><br>    var h = a + b + c;<br>    io:println(h); // @output fooAbc<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation.<br>Labels: additive-expr, string, value:toBalString<br><br>function init() {<br>    string a = "";<br>    string b = "hello ";<br>    string c = " world";<br>    string d = " from ballerina ";<br><br>    string s = a + a;<br>    printString(s); // @output ""<br>    printString(a + b); // @output "hello "<br>    printString(a + c); // @output " world"<br>    printString(a + d); // @output " from ballerina "<br><br>    printString(b + a); // @output "hello "<br>    printString(b + b); // @output "hello hello "<br>    printString(b + c); // @output "hello  world"<br>    printString(b + d); // @output "hello  from ballerina "<br><br>    printString(c + a); // @output " world"<br>    printString(c + b); // @output " worldhello "<br>    printString(c + c); // @output " world world"<br>    printString(c + d); // @output " world from ballerina "<br><br>    printString(d + a); // @output " from ballerina "<br>    printString(d + b); // @output " from ballerina hello "<br>    printString(d + c); // @output " from ballerina  world"<br>    printString(d + d); // @output " from ballerina  from ballerina "<br>}<br><br>function printString(string s) {<br>    io:println(s.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation with string:Char.<br>Labels: additive-expr, string, string:Char, value:toBalString<br><br>function init() {<br>    string:Char a = "_";<br>    string:Char b = "x";<br>    string:Char c = " ";<br>    string:Char d = "y";<br><br>    string s = a + a;<br>    printString(s); // @output "__"<br>    printString(a + b); // @output "_x"<br>    printString(a + c); // @output "_ "<br>    printString(a + d); // @output "_y"<br><br>    printString(b + a); // @output "x_"<br>    printString(b + b); // @output "xx"<br>    printString(b + c); // @output "x "<br>    printString(b + d); // @output "xy"<br><br>    printString(c + a); // @output " _"<br>    printString(c + b); // @output " x"<br>    printString(c + c); // @output "  "<br>    printString(c + d); // @output " y"<br><br>    printString(d + a); // @output "y_"<br>    printString(d + b); // @output "yx"<br>    printString(d + c); // @output "y "<br>    printString(d + d); // @output "yy"<br>}<br><br>function printString(string s) {<br>    io:println(s.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation with user-defined subtype of string.<br>Labels: additive-expr, string, value:toBalString, module-type-defn, union-type, singleton-type<br><br>type Chars "a"|"b";<br>type Strings "c"|"de";<br><br>function init() {<br>    Chars a = "a";<br>    Chars b = "b";<br>    Strings c = "c";<br>    Strings d = "de";<br><br>    string s = a + a;<br>    printString(s); // @output "aa"<br>    printString(a + b); // @output "ab"<br>    printString(a + c); // @output "ac"<br>    printString(a + d); // @output "ade"<br><br>    s = b + a;<br>    printString(s); // @output "ba"<br>    printString(b + b); // @output "bb"<br>    printString(b + c); // @output "bc"<br>    printString(b + d); // @output "bde"<br><br>    s = c + a;<br>    printString(c + a); // @output "ca"<br>    printString(c + b); // @output "cb"<br>    printString(c + c); // @output "cc"<br>    printString(c + d); // @output "cde"<br><br>    s = d + a;<br>    printString(s); // @output "dea"<br>    printString(d + b); // @output "deb"<br>    printString(d + c); // @output "dec"<br>    printString(d + d); // @output "dede"<br>}<br><br>function printString(string s) {<br>    io:println(s.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test concatenation of string:Char and user-defined string subtype variable holding a string:Char.<br>Labels: additive-expr, string, string:Char, value:toBalString, module-type-defn, union-type, singleton-type<br><br>type Strings "a"|"bc";<br><br>function init() {<br>    Strings a = "a";<br>    string:Char b = "b";<br><br>    string s = a + b;<br>    printString(s); // @output "ab"<br>    printString(b + a); // @output "ba"<br>}<br><br>function printString(string s) {<br>    io:println(s.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test concatenation of string:Char and user-defined string subtype variable holding a non-string:Char value.<br>Labels: additive-expr, string, string:Char, value:toBalString, module-type-defn, union-type, singleton-type<br><br>type Strings "a"|"bc";<br><br>function init() {<br>    Strings a = "bc";<br>    string:Char b = "d";<br><br>    string s = a + b;<br>    printString(s); // @output "bcd"<br>    printString(b + a); // @output "dbc"<br>}<br><br>function printString(string s) {<br>    io:println(s.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test concatenation of string:Char and string.<br>Labels: additive-expr, string, string:Char, value:toBalString<br><br>function init() {<br>    string:Char a = "d";<br>    string b = "efg";<br>    string c = "h";<br><br>    string s = a + b;<br>    printString(s); // @output "defg"<br>    printString(a + c); // @output "dh"<br><br>    s = b + a;<br>    printString(s); // @output "efgd"<br>    printString(c + a); // @output "hd"<br>}<br><br>function printString(string s) {<br>    io:println(s.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test concatenation of string and user-defined string subtype.<br>Labels: additive-expr, string, string:Char, value:toBalString, module-type-defn, union-type, singleton-type<br><br>type Strings "a"|"bc";<br><br>function init() {<br>    Strings a = "a";<br>    Strings b = "bc";<br>    string c = "d";<br>    string d = "ef";<br><br>    string s = a + c;<br>    printString(s); // @output "ad"<br>    printString(a + d); // @output "aef"<br><br>    s = b + c;<br>    printString(s); // @output "bcd"<br>    printString(b + d); // @output "bcef"<br><br>    s = c + a;<br>    printString(s); // @output "da"<br>    printString(c + b); // @output "dbc"<br><br>    s = d + a;<br>    printString(s); // @output "efa"<br>    printString(d + b); // @output "efbc"<br>}<br><br>function printString(string s) {<br>    io:println(s.toBalString());<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test concatenation of string with StringSingleEscape.<br>Labels: additive-expr, string, StringSingleEscape, value:toBalString<br><br>function init() {<br>    string a = "a\tb";<br>    string b = "\nc";<br>    string c = "\\";<br>    string d = "\"d\"";<br><br>    io:println(a + a); // @output a	ba	b<br>    io:println(a + b); // @output a	b<br>                       // @output c<br>    io:println(a + c); // @output a	b\<br>    io:println(a + d); // @output a	b"d"<br><br>    io:println((b + a).toBalString()); // @output "<br>                                       // @output ca	b"<br>    io:println((b + b).toBalString()); // @output "<br>                                       // @output c<br>                                       // @output c"<br>    io:println((b + c).toBalString()); // @output "<br>                                       // @output c\"<br>    io:println((b + d).toBalString()); // @output "<br>                                       // @output c"d""<br><br>    io:println(c + a); // @output \a	b<br>    io:println(c + b); // @output \<br>                       // @output c<br>    io:println(c + c); // @output \\<br>    io:println(c + d); // @output \"d"<br><br>    io:println(d + a); // @output "d"a	b<br>    io:println(d + b); // @output "d"<br>                       // @output c<br>    io:println(d + c); // @output "d"\<br>    io:println(d + d); // @output "d""d"<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation with string literal and string template expressions as operands.<br>Labels: additive-expr, string, BacktickString<br><br>function init() {<br>    string name = "ballerina";<br>    io:println("hello " + string `world from ${name}`); // @output hello world from ballerina<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation with field access expressions as operands.<br>Labels: additive-expr, string, field-access-expr, explicit-new-expr, module-class-defn, record-type<br><br>function init() {<br>    Bar b = {name: "test"};<br>    io:println(b.name + (new Foo()).id); // @output testABC<br>}<br><br>class Foo {<br>    string id = "ABC";<br>}<br><br>type Bar record {|<br>    string name;<br>|};<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation with function call and method call expressions as operands.<br>Labels: additive-expr, string, function-call-expr, method-call-expr, implicit-new-expr, explicit-new-expr, module-class-defn<br><br>function init() {<br>    Class cl = new;<br>    io:println(getString() + cl.getString()); // @output foobar<br>    io:println(cl.getString() + getString()); // @output barfoo<br>    io:println(getString() + getString()); // @output foofoo<br>    io:println(cl.getString() + (new Class()).getString()); // @output barbar<br>}<br><br>function getString() returns string {<br>    return "foo";<br>}<br><br>class Class {<br>    function getString() returns string {<br>        return "bar";<br>    }<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation with let expressions as operands.<br>Labels: additive-expr, string, let-expr<br><br>function init() {<br>    string s = (let string a = "hello", string b = "world" in a + " " + b ) + let string a = "!" in a;<br>    io:println(s); // @output hello world!<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation with conditional expressions as operands.<br>Labels: additive-expr, string, union-type, optional-type, error, conditional-expr<br><br>function init() {<br>    string? s = "hello";<br>    string|error t = " world";<br>    string u = (s ?: "hi") + (t is error ? "!" : t);<br>    io:println(u); // @output hello world<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation with checking expressions as operands.<br>Labels: additive-expr, string, union-type, optional-type, error, check, checkpanic<br><br>function init() returns error? {<br>    string|error s = "hello";<br>    string|error t = " world";<br>    string u = check s + checkpanic t;<br>    io:println(u); // @output hello world<br>    io:println(check s + checkpanic t); // @output hello world<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string concatenation at module level.<br>Labels: additive-expr, module-type-defn, module-init-var-decl, string, string:Char, union-type<br><br>type Strings "foo"|"bar";<br><br>string s = "one";<br>string:Char t = "2";<br>Strings u = "foo";<br><br>string str = s + t + u;<br><br>function init() returns error? {<br>    io:println(str); // @output one2foo<br>}</pre>
<h3>string_xml_addition.balt</h3>
<pre>Test-Case: error<br>Description: Test invalid static type of string and XML concatenation.<br>Labels: additive-expr, xml, string, xml:Element<br><br>function errorFunction(xml a, string b) {<br>    string _ = a + b; // @error static type of string and xml concatenation is xml<br>    string _ = a + b + a; // @error static type of string and xml concatenation is xml<br>    xml:Element _ = a + b; // @error static type of string and xml concatenation is xml<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test invalid static type of string built-in subtype and xml concatenation.<br>Labels: additive-expr, xml, string, string:Char<br><br>function errorFunction(xml a, string f, string:Char g) {<br>    string _ = a + f; // @error static type of string and xml concatenation is xml<br>    string _ = g + a; // @error static type of string and xml concatenation is xml<br>    string _ = g + a + f; // @error static type of string and xml concatenation is xml<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test invalid static type of user-defined string subtype and xml concatenation.<br>Labels: additive-expr, xml, string, module-type-defn, union-type, singleton-type, string-literal<br><br>type Strings "foo";<br>type Chars "a"|"b";<br><br>function errorFunction(xml a, Strings f, Chars g) {<br>    string _ = a + f; // @error static type of string and xml concatenation is xml<br>    string _ = g + a; // @error static type of string and xml concatenation is xml<br>    string _ = g + a + f; // @error static type of string and xml concatenation is xml<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test invalid static type of string built-in subtype and xml built-in subtype concatenation.<br>Fail-Issue: ballerina-platform/ballerina-lang#32975<br>Labels: additive-expr, xml, int, xml:Element, xml:Comment, xml:ProcessingInstruction, string, string:Char<br><br>function errorFunction(xml:Element b, xml:Comment c, xml:ProcessingInstruction d, string f, string:Char g) {<br>    xml:Element _ = b + f; // @error static type of string and xml concatenation is xml<br>    string _ = g + b; // @error static type of string and xml concatenation is xml<br>    string _ = g + b + g; // @error static type of string and xml concatenation is xml<br>    xml:Comment _ = c + f; // @error static type of string and xml concatenation is xml<br>    string _ = c + (g + c); // @error static type of string and xml concatenation is xml<br>    int _ = d + f; // @error static type of string and xml concatenation is xml<br>    xml:ProcessingInstruction _ = g + d; // @error static type of string and xml concatenation is xml<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test invalid static type of user-defined string subtype and xml subtype concatenation.<br>Fail-Issue: ballerina-platform/ballerina-lang#32975<br>Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, module-type-defn, union-type, singleton-type, string, string-literal<br><br>type Strings "foo";<br>type Chars "a"|"b";<br><br>function errorFunction(xml:Element b, xml:Comment c, xml:ProcessingInstruction d, Strings f, Chars g) {<br>    xml:Element _ = b + f; // @error static type of string and xml concatenation is xml<br>    string _ = g + b; // @error static type of string and xml concatenation is xml<br>    string _ = g + b + g; // @error static type of string and xml concatenation is xml<br>    xml:Comment _ = c + f; // @error static type of string and xml concatenation is xml<br>    string _ = c + (g + c); // @error static type of string and xml concatenation is xml<br>    string _ = d + f; // @error static type of string and xml concatenation is xml<br>    xml:ProcessingInstruction _ = g + d; // @error static type of string and xml concatenation is xml<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test invalid optional xml and string concatenation.<br>Labels: additive-expr, xml, string, optional-type<br><br>function errorFunction(xml? a, string? b, string c) {<br>    xml _ = a + b; // @error cannot concatenate optional xml and optional string<br>    xml? _ = a + b; // @error cannot concatenate optional xml and optional string<br>    xml _ = a + c; // @error cannot concatenate optional xml and string<br>    xml _ = c + a + c; // @error cannot concatenate optional xml and optional string<br>    string? _ = c + a + c; // @error cannot concatenate optional xml, optional string, and string<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test invalid optional xml and string subtype concatenation.<br>Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, string, string:Char, optional-type, union-type<br><br>function errorFunction(xml? a, xml:Element? b, xml:Comment? c, xml:ProcessingInstruction? d, xml:Text? e, string? f, string:Char? g) {<br>    xml _ = a + f; // @error cannot concatenate optional xml and string<br>    xml? _ = a + g; // @error cannot concatenate optional xml and string<br>    xml? _ = g + b; // @error cannot concatenate optional xml and string<br>    xml? _ = f + c; // @error cannot concatenate optional xml and string<br>    string? _ = d + f + g + e; // @error cannot concatenate optional xml and string<br>    xml:ProcessingInstruction|xml:Text? _ = f + d + e + f; // @error cannot concatenate optional xml and string<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test xml and string concatenation static type via invalid assignment with var.<br>Fail-Issue: ballerina-platform/ballerina-lang#32975<br>Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, var, module-type-defn, string, string-literal, singleton-type<br><br>type Foo "foo";<br><br>function errorFunction(xml a, xml:Element b, xml:Comment c, xml:ProcessingInstruction d, xml:Text e, string f, string:Char g, Foo h) {<br>    var i = a + f;<br>    string _ = i; // @error incompatible types: expected string found xml<br><br>    var j = b + g;<br>    string _ = j; // @error incompatible types: expected string found xml<br><br>    var k = h + c;<br>    Foo _ = k; // @error incompatible types: expected Foo found xml<br><br>    var l = d + g;<br>    xml:ProcessingInstruction _ = l; // @error incompatible types: expected xml:ProcessingInstruction found xml<br><br>    var m = e + f + g;<br>    string _ = m; // @error incompatible types: expected string found xml<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test xml and string concatenation static type via invalid assignment with var.<br>Fail-Issue: ballerina-platform/ballerina-lang#32976<br>Labels: additive-expr, xml, xml:Element, xml:Comment, xml-type-parameter, union-type, singleton-type, var, module-type-defn, string-literal<br><br>type Foo "foo";<br><br>function errorFunction(Foo a, xml<xml:Element|xml:Comment> b) {<br>    var n = a + b;<br>    xml<xml:Element|xml:Comment> _ = n; // @error incompatible types: expected xml<xml:Element|xml:Comment> found xml<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test static type of empty xml and string concatentation via invalid assignment with var.<br>Fail-Issue: ballerina-platform/ballerina-lang#32984, ballerina-platform/ballerina-lang#32976<br>Labels: additive-expr, xml, xml-type-parameter, never, module-type-defn, union-type, singleton-type, string, string:Char, var<br><br>type Foo "foo"|"bar";<br><br>function errorFunction() {<br>    string a = "";<br>    string:Char b = "b";<br>    Foo c = "foo";<br>    xml<never> d = xml ``;<br><br>    var e = a + d;<br>    string _ = e; // @error static type of string and empty xml concatenation is xml:Text<br><br>    var f = b + d;<br>    string _ = f; // @error static type of string and empty xml concatenation is xml:Text<br><br>    var g = c + d;<br>    string _ = g; // @error static type of string and empty xml concatenation is xml:Text<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test invalid static type of string union and xml union concatenation.<br>Fail-Issue: ballerina-platform/ballerina-lang#33059<br>Labels: additive-expr, string, string:Char, module-type-defn, union-type, singleton-type, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, xml-type-parameter<br><br>type Strings "A"|"foo";<br>type Chars "B"|"bar";<br><br>function errorFunction(string a, string:Char|Strings b, Strings|Chars c, xml:Element|xml:Comment d, xml<xml:ProcessingInstruction|xml:Text> e, xml f) {<br>    string _ = a + d; // @error static type of concatenation is xml<xml:Text|xml:Element|xml:Comment><br>    string _ = b + d; // @error static type of concatenation is xml<xml:Text|xml:Element|xml:Comment><br>    string _ = c + e; // @error static type of concatenation is xml<xml:Text|xml:ProcessingInstruction><br>    string _ = b + f; // @error static type of concatenation is xml<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test additive expression with operands of types that are a subtype of the union of xml and string, but not individually of xml or string.<br>Labels: additive-expr, string, string:Char, module-type-defn, union-type, singleton-type, xml, xml:Element, xml:Comment, xml:Text, xml-type-parameter<br><br>type Strings "A"|"foo";<br><br>function errorFunction(string:Char|xml a, xml:Element|Strings b, xml<xml:Comment|xml:Text>|string c) {<br>    xml _ = a + a; // @error static type of operands have to be a subtype of xml or string<br>    xml _ = a + b; // @error static type of operands have to be a subtype of xml or string<br>    xml _ = a + c; // @error static type of operands have to be a subtype of xml or string<br>    xml _ = b + b; // @error static type of operands have to be a subtype of xml or string<br>    xml _ = b + c; // @error static type of operands have to be a subtype of xml or string<br>    xml _ = c + c; // @error static type of operands have to be a subtype of xml or string<br>}<br></pre>
<pre>Test-Case: error<br>Description: Test invalid static type of string and xml concatenation with sequences of sequences.<br>Fail-Issue: ballerina-platform/ballerina-lang#33066<br>Labels: additive-expr, xml, string, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, union-type, xml-type-parameter<br><br>function errorFunction(string a, xml<xml<xml:Element|xml:Comment>> b, xml<xml<xml<xml:Text|xml:ProcessingInstruction>>> c) {<br>    string _ = a + b; // @error static type of concatenation is xml<xml:Text|xml:Element|xml:Comment><br>    string _ = a + c; // @error static type of concatenation is xml<xml:Text|xml:ProcessingInstruction><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml concatenation for singleton value and empty string.<br>Labels: additive-expr, xml, string<br><br>function init() {<br>    xml a = xml `foo`;<br>    xml b = xml `<!--bar-->`;<br>    xml c = xml `<baz/>`;<br>    xml d = xml `<?qux?>`;<br>    string e = "";<br><br>    xml f = a + e;<br>    io:println(f); // @output foo<br>    io:println(e + a); // @output foo<br><br>    f = e + b;<br>    io:println(f); // @output <!--bar--><br>    io:println(b + e); // @output <!--bar--><br><br>    f = c + e;<br>    io:println(f); // @output <baz></baz><br>    io:println(e + c + e); // @output <baz></baz><br><br>    f = d + e;<br>    io:println(f); // @output <?qux ?><br>    io:println(e + d); // @output <?qux ?><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml concatenation for singleton value and empty string returning the xml value.<br>Fail-Issue: ballerina-platform/ballerina-lang#32978<br>Labels: additive-expr, xml, string, any, xml:get<br><br>function init() {<br>    xml a = xml `foo`;<br>    xml b = xml `<!--bar-->`;<br>    xml c = xml `<baz/>`;<br>    xml d = xml `<?qux?>`;<br>    string e = "";<br>    any f = e;<br><br>    xml g = a + e;<br>    io:println(g === a); // @output true<br>    io:println(g.get(0) === a); // @output true<br>    io:println(g === f); // @output false<br><br>    g = e + b;<br>    io:println(g === b); // @output true<br>    io:println(g.get(0) === b); // @output true<br>    io:println(g === f); // @output false<br><br>    g = c + e;<br>    io:println(g === c); // @output true<br>    io:println(g.get(0) === c); // @output true<br>    io:println(g === f); // @output false<br><br>    g = d + e;<br>    io:println(g === d); // @output true<br>    io:println(g.get(0) === d); // @output true<br>    io:println(g === f); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and empty string concatenation with sequences.<br>Labels: additive-expr, xml, xml-type-parameter, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, string<br><br>function init() {<br>    xml a = xml `foo`;<br>    xml b = xml `bar<!--bar-->`;<br>    xml<xml:Element|xml:ProcessingInstruction> c = xml `<baz/><?qux?>`;<br>    string d = "";<br><br>    xml e = b + d;<br>    io:println(e); // @output bar<!--bar--><br><br>    e = c + d;<br>    io:println(e); // @output <baz></baz><?qux ?><br><br>    e = c + d + c;<br>    io:println(e); // @output <baz></baz><?qux ?><baz></baz><?qux ?><br><br>    e = a + d + b + d;<br>    io:println(e); // @output foobar<!--bar--><br><br>    e = a + d + b + d + c;<br>    io:println(e); // @output foobar<!--bar--><baz></baz><?qux ?><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml concatenation with different subtypes of xml and string with empty string as the string value.<br>Fail-Issue: ballerina-platform/ballerina-lang#32975<br>Labels: additive-expr, xml, string, xml-type-parameter, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, never, module-type-defn, union-type, singleton-type, is-expr<br><br>type Foo "foo"|"";<br><br>function init() {<br>    xml:Text a = xml `foo`;<br>    xml:Comment b = xml `<!--bar-->`;<br>    xml:Element c = xml `<baz>baz value</baz>`;<br>    xml:ProcessingInstruction d = xml `<?qux val?>`;<br>    xml<xml:Text|xml:Comment> e = xml `<!--c1--> <!--c2-->`;<br>    string f = "";<br>    Foo g = "";<br><br>    xml:Text h = a + f;<br>    io:println(h); // @output foo<br>    io:println(h is xml:Text); // @output true<br><br>    h = a + g;<br>    io:println(h); // @output foo<br>    io:println(h is xml:Text); // @output true<br><br>    xml i = b + f;<br>    io:println(i); // @output <!--bar--><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Comment); // @output true<br><br>    i = b + g;<br>    io:println(i); // @output <!--bar--><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Comment); // @output true<br><br>    i = c + f;<br>    io:println(i); // @output <baz>baz value</baz><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Element); // @output true<br><br>    i = c + g;<br>    io:println(i); // @output <baz>baz value</baz><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Element); // @output true<br><br>    i = d + f;<br>    io:println(i); // @output <?qux val?><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:ProcessingInstruction); // @output true<br><br>    i = g + d;<br>    io:println(i); // @output <?qux val?><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:ProcessingInstruction); // @output true<br><br>    i = e + f;<br>    io:println(i); // @output <!--c1--> <!--c2--><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml<xml:Comment|xml:Text>); // @output true<br><br>    i = g + e;<br>    io:println(i); // @output <!--c1--> <!--c2--><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml<xml:Comment|xml:Text>); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test concatenation of empty xml sequence and empty string.<br>Labels: additive-expr, xml, xml-type-parameter, never, value:toBalString, string, module-type-defn, union-type, singleton-type, is-expr<br><br>type Foo ""|"foo";<br><br>function init() {<br>    string a = "";<br>    Foo b = "";<br>    xml c = xml ``;<br>    xml<never> d = xml ``;<br><br>    xml e = a + c;<br>    io:println(e.toBalString()); // @output xml``<br>    io:println(e is xml:Text); // @output true<br>    io:println(e is xml<never>); // @output true<br><br>    e = a + d;<br>    io:println(e.toBalString()); // @output xml``<br>    io:println(e is xml:Text); // @output true<br>    io:println(e is xml<never>); // @output true<br><br>    e = c + b;<br>    io:println(e.toBalString()); // @output xml``<br>    io:println(e is xml:Text); // @output true<br>    io:println(e is xml<never>); // @output true<br><br>    e = d + b;<br>    io:println(e.toBalString()); // @output xml``<br>    io:println(e is xml:Text); // @output true<br>    io:println(e is xml<never>); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test value of empty xml and string concatentation using the exact static type.<br>Labels: additive-expr, xml, xml-type-parameter, never, value:toBalString, string, module-type-defn, union-type, singleton-type, is-expr, string:Char<br><br>type Foo "foo"|"bar";<br><br>function init() {<br>    string a = "";<br>    string:Char b = "b";<br>    Foo c = "foo";<br>    xml:Text d = xml ``;<br>    xml<never> e = xml ``;<br>    xml f = xml ``;<br><br>    xml:Text g = a + d;<br>    io:println(e.toBalString()); // @output xml``<br>    io:println(e is xml<never>); // @output true<br><br>    xml i = a + f;<br>    io:println(i.toBalString()); // @output xml``<br>    io:println(i is xml<never>); // @output true<br><br>    xml:Text j = b + d;<br>    io:println(j.toBalString()); // @output xml`b`<br>    io:println(j is xml<never>); // @output false<br><br>    xml l = b + f;<br>    io:println(l.toBalString()); // @output xml`b`<br>    io:println(l is xml<never>); // @output false<br><br>    xml:Text m = c + d;<br>    io:println(m.toBalString()); // @output xml`foo`<br>    io:println(m is xml<never>); // @output false<br><br>    xml:Text n = c + e;<br>    io:println(n.toBalString()); // @output xml`foo`<br>    io:println(n is xml<never>); // @output false<br><br>    xml o = c + f;<br>    io:println(o.toBalString()); // @output xml`foo`<br>    io:println(o is xml<never>); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test value of empty xml (as xml<never>) and string concatentation using the exact static type.<br>Fail-Issue: ballerina-platform/ballerina-lang#32984<br>Labels: additive-expr, xml, xml-type-parameter, never, value:toBalString, string, is-expr, string:Char<br><br>function init() {<br>    string a = "";<br>    string:Char b = "b";<br>    xml<never> e = xml ``;<br><br>    xml:Text g = a + e;<br>    io:println(e.toBalString()); // @output xml``<br>    io:println(e is xml<never>); // @output true<br><br>    xml:Text j = b + e;<br>    io:println(j.toBalString()); // @output xml`b`<br>    io:println(j is xml<never>); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml concatenation for singleton value and non-empty string.<br>Labels: additive-expr, xml, string, value:toBalString<br><br>function init() {<br>    xml a = xml `foo`;<br>    xml b = xml `<!--bar-->`;<br>    xml c = xml `<baz/>`;<br>    xml d = xml `<?qux?>`;<br>    string e = "string value";<br><br>    xml f = a + e;<br>    io:println(f.toBalString()); // @output xml`foostring value`<br>    io:println(e + a); // @output string valuefoo<br><br>    f = e + b;<br>    io:println(f); // @output string value<!--bar--><br>    io:println((b + e).toBalString()); // @output xml`<!--bar-->string value`<br><br>    f = c + e;<br>    io:println(f.toBalString()); // @output xml`<baz></baz>string value`<br>    io:println(e + c + e); // @output string value<baz></baz>string value<br><br>    f = d + e;<br>    io:println(f.toBalString()); // @output xml`<?qux ?>string value`<br>    io:println(e + d); // @output string value<?qux ?><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and non-empty string concatenation with sequences.<br>Labels: additive-expr, xml, xml-type-parameter, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, string, value:toBalString<br><br>function init() {<br>    xml a = xml `foo`;<br>    xml b = xml `bar<!--bar-->`;<br>    xml<xml:Element|xml:ProcessingInstruction> c = xml `<baz/><?qux?>`;<br>    string d = "str";<br><br>    xml e = b + d;<br>    io:println(e.toBalString()); // @output xml`bar<!--bar-->str`<br>    io:println(e); // @output bar<!--bar-->str<br><br>    e = c + d;<br>    io:println(e); // @output <baz></baz><?qux ?>str<br>    io:println((d + c).toBalString()); // @output xml`str<baz></baz><?qux ?>`<br><br>    e = c + d + c;<br>    io:println(e); // @output <baz></baz><?qux ?>str<baz></baz><?qux ?><br>    io:println(e.toBalString()); // @output xml`<baz></baz><?qux ?>str<baz></baz><?qux ?>`<br><br>    e = a + d + b + d;<br>    io:println(e.toBalString()); // @output xml`foostrbar<!--bar-->str`<br><br>    e = a + d + b + d + c;<br>    io:println(e); // @output foostrbar<!--bar-->str<baz></baz><?qux ?><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml concatenation with different subtypes of xml and string with a non-empty string as the string value.<br>Fail-Issue: ballerina-platform/ballerina-lang#32975<br>Labels: additive-expr, xml, string, xml-type-parameter, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, never, is-expr, union-type<br><br>function init() {<br>    xml:Text a = xml `foo`;<br>    xml:Comment b = xml `<!--bar-->`;<br>    xml:Element c = xml `<baz>baz value</baz>`;<br>    xml:ProcessingInstruction d = xml `<?qux val?>`;<br>    xml<xml:Text|xml:Comment> e = xml `<!--c1--> <!--c2-->`;<br>    string f = "barval";<br><br>    xml:Text h = a + f;<br>    io:println(h); // @output foobarval<br>    io:println(h is xml:Text); // @output true<br><br>    xml i = b + f;<br>    io:println(i); // @output <!--bar-->barval<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Comment); // @output false<br>    io:println(i is xml<xml:Comment|xml:Text>); // @output true<br><br>    i = c + f;<br>    io:println(i); // @output <baz>baz value</baz>barval<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Element); // @output false<br>    io:println(i is xml<xml:Element|xml:Text>); // @output true<br><br>    i = d + f;<br>    io:println(i); // @output <?qux val?>barval<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:ProcessingInstruction); // @output false<br>    io:println(i is xml<xml:ProcessingInstruction|xml:Text>); // @output true<br><br>    i = e + f;<br>    io:println(i); // @output <!--c1--> <!--c2-->barval<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml<xml:Comment|xml:Text>); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml concatenation with different subtypes of xml and subtype of string with a non-empty string as the string value.<br>Fail-Issue: ballerina-platform/ballerina-lang#32975<br>Labels: additive-expr, xml, string:Char, xml-type-parameter, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, never, module-type-defn, union-type, singleton-type, is-expr<br><br>type Foo "fooval"|"";<br><br>function init() {<br>    xml:Text a = xml `foo`;<br>    xml:Comment b = xml `<!--bar-->`;<br>    xml:Element c = xml `<baz>baz value</baz>`;<br>    xml:ProcessingInstruction d = xml `<?qux val?>`;<br>    xml<xml:Text|xml:Comment> e = xml `<!--c1--> <!--c2-->`;<br>    string:Char f = "F";<br>    Foo g = "fooval";<br><br>    xml:Text h = a + f;<br>    io:println(h); // @output fooF<br>    io:println(h is xml:Text); // @output true<br><br>    h = a + g;<br>    io:println(h); // @output foofooval<br>    io:println(h is xml:Text); // @output true<br><br>    xml i = b + f;<br>    io:println(i); // @output <!--bar-->F<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Comment); // @output false<br>    io:println(i is xml<xml:Comment|xml:Text>); // @output true<br><br>    i = b + g;<br>    io:println(i); // @output <!--bar-->fooval<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Comment); // @output false<br>    io:println(i is xml<xml:Comment|xml:Text>); // @output true<br><br>    i = c + f;<br>    io:println(i); // @output <baz>baz value</baz>F<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Element); // @output false<br>    io:println(i is xml<xml:Element|xml:Text>); // @output true<br><br>    i = c + g;<br>    io:println(i); // @output <baz>baz value</baz>fooval<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:Element); // @output false<br>    io:println(i is xml<xml:Element|xml:Text>); // @output true<br><br>    i = d + f;<br>    io:println(i); // @output <?qux val?>F<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:ProcessingInstruction); // @output false<br>    io:println(i is xml<xml:ProcessingInstruction|xml:Text>); // @output true<br><br>    i = g + d;<br>    io:println(i); // @output fooval<?qux val?><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml:ProcessingInstruction); // @output false<br>    io:println(i is xml<xml:ProcessingInstruction|xml:Text>); // @output true<br><br>    i = e + f;<br>    io:println(i); // @output <!--c1--> <!--c2-->F<br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml<xml:Comment|xml:Text>); // @output true<br><br>    i = g + e;<br>    io:println(i); // @output fooval<!--c1--> <!--c2--><br>    io:println(i is xml:Text); // @output false<br>    io:println(i is xml<xml:Comment|xml:Text>); // @output true<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test concatenation of empty xml sequence and non-empty string.<br>Labels: additive-expr, xml, xml-type-parameter, never, value:toBalString, string, is-expr<br><br>function init() {<br>    string a = "str";<br>    xml d = xml ``;<br>    xml<never> e = xml ``;<br><br>    xml f = a + d;<br>    io:println(f.toBalString()); // @output xml`str`<br>    io:println(f is xml:Text); // @output true<br>    io:println(f is xml<never>); // @output false<br><br>    f = a + e;<br>    io:println(f.toBalString()); // @output xml`str`<br>    io:println(f is xml:Text); // @output true<br>    io:println(f is xml<never>); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test concatenation of empty xml sequence and non-empty string.<br>Labels: additive-expr, xml, xml-type-parameter, never, value:toBalString, string:Char, module-type-defn, union-type, singleton-type, is-expr<br><br>type Foo ""|"foo";<br><br>function init() {<br>    Foo b = "foo";<br>    string:Char c = "C";<br>    xml d = xml ``;<br>    xml<never> e = xml ``;<br><br>    xml f = d + b;<br>    io:println(f.toBalString()); // @output xml`foo`<br>    io:println(f is xml:Text); // @output true<br>    io:println(f is xml<never>); // @output false<br><br>    f = e + b;<br>    io:println(f.toBalString()); // @output xml`foo`<br>    io:println(f is xml:Text); // @output true<br>    io:println(f is xml<never>); // @output false<br><br>    f = d + c;<br>    io:println(f.toBalString()); // @output xml`C`<br>    io:println(f is xml:Text); // @output true<br>    io:println(f is xml<never>); // @output false<br><br>    f = e + c;<br>    io:println(f.toBalString()); // @output xml`C`<br>    io:println(f is xml:Text); // @output true<br>    io:println(f is xml<never>); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string and xml concatenation when an operand is of a union type containing builtin subtypes of string and xml.<br>Fail-Issue: ballerina-platform/ballerina-lang#33059<br>Labels: additive-expr, string, string:Char, module-type-defn, union-type, singleton-type, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, xml-type-parameter<br><br>type Strings "A"|"foo";<br>type Chars "B"|"bar";<br><br>function init() {<br>    string:Char|Strings a = "M";<br>    string:Char|Chars b = "bar";<br>    xml:Element|xml:ProcessingInstruction c = xml `<?pi value?>`;<br>    xml<xml:Comment|xml:Text> d = xml `<!--c1--> <!--c2-->`;<br><br>    xml<xml:Element|xml:ProcessingInstruction|xml:Text> h = a + c;<br>    io:println(h); // @output M<?pi value?><br><br>    xml<xml:Text|xml:Comment> i = a + d;<br>    io:println(i); // @output M<!--c1--> <!--c2--><br><br>    xml<xml:Element|xml:ProcessingInstruction|xml:Text> j = c + b;<br>    io:println(j); // @output <?pi value?>bar<br><br>    xml<xml:Text|xml:Comment> k = b + d;<br>    io:println(k); // @output bar<!--c1--> <!--c2--><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string and xml concatenation with sequences of sequences.<br>Labels: additive-expr, is-expr, xml, string, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, union-type, xml-type-parameter<br><br>function init() {<br>    string a = "foo";<br>    xml<xml<xml:Element|xml:Comment>> b =  xml `<!--c1--><foo>1</foo>`;<br>    xml<xml<xml<xml:Text|xml:ProcessingInstruction>>> c = xml `<?bar val?>text`;<br><br>    xml x = a + b;<br>    io:println(x); // @output foo<!--c1--><foo>1</foo><br>    io:println(x is xml<xml:Element|xml:Comment|xml:Text>); // @output true<br>    io:println(x is xml<xml:Element|xml:Comment>); // @output false<br><br>    x = a + c;<br>    io:println(x); // @output foo<?bar val?>text<br>    io:println(x is xml<xml:Text|xml:ProcessingInstruction>); // @output true<br>    io:println(x is xml<xml:Text>); // @output false<br><br>    x = b + c;<br>    io:println(x); // @output <!--c1--><foo>1</foo><?bar val?>text<br>    io:println(x is xml<xml:Text|xml:ProcessingInstruction|xml:Comment|xml:Element>); // @output true<br>    io:println(x is xml<xml:ProcessingInstruction|xml:Comment|xml:Element>); // @output false<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string and xml concatenation with sequences of sequences with exact static types.<br>Fail-Issue: ballerina-platform/ballerina-lang#33066<br>Labels: additive-expr, xml, string, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, union-type, xml-type-parameter<br><br>function init() {<br>    string a = "foo";<br>    xml<xml<xml:Element|xml:Comment>> b =  xml `<!--c1--><foo>1</foo>`;<br>    xml<xml<xml<xml:Text|xml:ProcessingInstruction>>> c = xml `<?bar val?>text`;<br><br>    xml<xml:Element|xml:Comment|xml:Text> x = a + b;<br>    io:println(x); // @output foo<!--c1--><foo>1</foo><br><br>    xml<xml:Text|xml:ProcessingInstruction> y = a + c;<br>    io:println(y); // @output foo<?bar val?>text<br><br>    xml<xml:Text|xml:ProcessingInstruction|xml:Comment|xml:Element> z = b + c;<br>    io:println(x); // @output <!--c1--><foo>1</foo><?bar val?>text<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and string concatenation with xml and string literal expressions as operands.<br>Fail-Issue: ballerina-platform/ballerina-lang#32975<br>Labels: additive-expr, xml, int, string<br><br>function init() {<br>    int id = 21;<br>    io:println("hello" + xml `<count>${id}</count>`); // @output hello<count>21</count><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and string concatenation with field access expressions as operands.<br>Labels: additive-expr, xml, field-access-expr, explicit-new-expr, module-class-defn, record-type<br><br>function init() {<br>    Bar b = {str: "value"};<br>    io:println(b.str + (new Foo()).id); // @output value<id>1234</id><default></default><br>}<br><br>class Foo {<br>    xml id = xml `<id>1234</id><default/>`;<br>}<br><br>type Bar record {|<br>    string str;<br>|};<br></pre>
<pre>Test-Case: output<br>Description: Test xml and string concatenation with function call and method call expressions as operands.<br>Labels: additive-expr, xml, string, function-call-expr, method-call-expr, implicit-new-expr, explicit-new-expr, module-class-defn<br><br>function init() {<br>    Class cl = new;<br>    io:println(getXml() + cl.getXml()); // @output string value<!--Comment 1--> <!--Comment 2--><br>    io:println(cl.getXml() + getXml()); // @output <!--Comment 1--> <!--Comment 2-->string value<br>    io:println(getXml() + getXml()); // @output string valuestring value<br>    io:println(cl.getXml() + (new Class()).getXml()); // @output <!--Comment 1--> <!--Comment 2--><!--Comment 1--> <!--Comment 2--><br>}<br><br>function getXml() returns string {<br>    return "string value";<br>}<br><br>class Class {<br>    function getXml() returns xml<xml:Comment|xml:Text> {<br>        return xml `<!--Comment 1--> <!--Comment 2-->`;<br>    }<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and string concatenation with let expressions as operands.<br>Labels: additive-expr, xml, string:Char, let-expr, xml:Element<br><br>function init() {<br>    xml s = (let string:Char c = "c", xml:Element b = xml `<def/>` in c + xml ` ` + b) + let string:Char v = "v" in v;<br>    io:println(s); // @output c <def></def>v<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and string concatenation with type cast expressions as operands.<br>Labels: additive-expr, xml, type-cast-expr, optional-type, xml:Element, module-type-defn, string-literal, singleton-type<br><br>type Foo "foo";<br><br>function init() {<br>    xml? s = xml `<elem/>`;<br>    Foo? t = "foo";<br>    io:println(<Foo> t + <xml> s); // @output foo<elem></elem><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and string concatenation with additive expressions as operands.<br>Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, string<br><br>function init() {<br>    string r = "str";<br>    xml:Element s = xml `<elem>1234</elem>`;<br>    xml:Text t = xml `Hello World`;<br>    xml:ProcessingInstruction u = xml `<?pi 1?>`;<br>    xml:Comment v = xml `<!--comment 1-->`;<br>    xml w = xml `<foo/>1234<bar>1234</bar>`;<br><br>    xml x = (s + t + u + r) + v + r + w;<br>    io:println(x); // @output <elem>1234</elem>Hello World<?pi 1?>str<!--comment 1-->str<foo></foo>1234<bar>1234</bar><br><br>    xml y = s + t + u + r + v + r + w;<br>    io:println(y); // @output <elem>1234</elem>Hello World<?pi 1?>str<!--comment 1-->str<foo></foo>1234<bar>1234</bar><br><br>    xml z = (s + t) + u + r + v + r + w;<br>    io:println(z); // @output <elem>1234</elem>Hello World<?pi 1?>str<!--comment 1-->str<foo></foo>1234<bar>1234</bar><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and string concatenation with conditional expressions as operands.<br>Labels: additive-expr, xml, union-type, optional-type, error, conditional-expr, string:Char<br><br>function init() {<br>    xml? s = xml `foo`;<br>    string:Char|error t = "a";<br>    xml x = xml `<baz/>`;<br>    xml u = (s ?: x) + (t is error ? "foo" : t);<br>    io:println(u); // @output fooa<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and string concatenation with checking expressions as operands.<br>Labels: additive-expr, xml, string, union-type, optional-type, error, check, checkpanic, value:toBalString<br><br>function init() returns error? {<br>    xml|error s = xml `hello`;<br>    string|error t = " world";<br><br>    xml u = check s + checkpanic t;<br>    io:println(u.toBalString()); // @output xml`hello world`<br>    io:println(check s + check t + checkpanic s); // @output hello worldhello<br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml concatenation with string values with NumericEscape.<br>Labels: additive-expr, xml, string, StringNumericEscape<br><br>public function main() {<br>    xml a = xml `foo`;<br>    xml b = xml `<!--bar-->`;<br>    string c = "a\u{0040}b";<br>    string d = "\u{1E41}";<br><br>    xml f = a + c + b + d;<br>    io:println(f); // @output fooa@b<!--bar-->ṁ<br><br>    io:println(a + c); // @output fooa@b<br><br>    io:println(d + b); // @output ṁ<!--bar--><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml concatenation with string values with StringSingleEscape.<br>Labels: additive-expr, xml, string, StringSingleEscape, value:toBalString<br><br>public function main() {<br>    xml a = xml `foo`;<br>    xml b = xml `<!--bar-->`;<br>    string c = "a\nb";<br>    string d = "\\";<br><br>    xml f = c + a + b + d;<br>    io:println(f); // @output a<br>                   // @output bfoo<!--bar-->\<br><br>    io:println(a + c); // @output fooa<br>                       // @output b<br><br>    io:println(d + b); // @output \<!--bar--><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test string and xml concatenation at module level.<br>Labels: additive-expr, module-type-defn, module-init-var-decl, string, string:Char, union-type, xml, xml:Element<br><br>type Strings "foo"|"bar";<br><br>string s = "one";<br>string:Char t = "2";<br>Strings u = "foo";<br>xml v = xml `text`;<br>xml:Element w = xml `<elem>value</elem>`;<br><br>xml val = s + t + u + v + w;<br><br>function init() returns error? {<br>    io:println(val); // @output one2footext<elem>value</elem><br>}<br></pre>
<pre>Test-Case: output<br>Description: Test xml and string concatenation with var.<br>Fail-Issue: ballerina-platform/ballerina-lang#32975<br>Labels: additive-expr, string, var, xml, xml:Element<br><br>function init() {<br>    xml a = xml `foo`;<br>    xml:Element b = xml `<elem>value</elem>`;<br>    string c = "str";<br>    string:Char d = "D";<br><br>    var e = a + c;<br>    io:println(e); // @output foostr<br><br>    var f = a + d;<br>    io:println(f); // @output fooD<br><br>    var g = b + c + d;<br>    io:println(g); // @output <elem>value</elem>strD<br><br>    var h = b + d;<br>    io:println(h); // @output <elem>value</elem>D<br>}</pre>
</body>
</html>
